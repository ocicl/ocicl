(in-package :mgl-pax)

(in-readtable pythonic-string-syntax)

(defsection @parsing (:title "Parsing")
  "When encountering a @WORD such as `CLASSes`, PAX needs to find the
  @NAME in it that makes sense in the context. @CODIFICATION, for
  example, looks for @INTERESTING names, @NAVIGATING-IN-EMACS for
  names with [Lisp][lisp-locative-types function] DEFINITIONS, and
  @LINKING for names with [any kind of definition][locative-types
  function].

  This is not as straightforward as it sounds because it needs to
  handle cases like nonREADable, CLASSES, all the various forms of
  @LINKING in docstrings as well as in comments, and the `(NAME
  LOCATIVE)` syntax in DEFSECTION."
  (@word glossary-term)
  (@raw-name glossary-term)
  (@name glossary-term)
  "Depending on the context, trimming and depluralization may be
  enabled (see @RAW-NAMES-IN-WORDS), while the possible names may be
  restricted to symbols (see @NAMES-IN-RAW-NAMES).

  - _Trimming:_ Enabled for @NAVIGATING-IN-EMACS and @CODIFICATION.

  - _Depluralization:_ Enabled when the @WORD is part of the normal
    flow of text (i.e. not for @SPECIFIC-REFLINK-WITH-TEXT,
    @UNSPECIFIC-REFLINK-WITH-TEXT and various Elisp functions such as
    `mgl-pax-apropos` unless they determine their argument from buffer
    contents).

  - _Symbols only:_ This is the case for @CODIFICATION and
    @UNSPECIFIC-AUTOLINK to prevent string-based definitions from
    littering the documentation with links without the control
    provided by explicitly IMPORTing symbols."
  "For a word, a number of @RAW-NAMEs is generated by trimming
  delimiter characters and plural markers, and for each raw name a
  number of names are considered until one is found suitable in the
  context. The following subsections describe the details of the
  parsing algorithm."
  (@raw-names-in-words section)
  (@names-in-raw-names section)
  """<br/>
  For example, when `\\M-.` is pressed while point is over
  `nonREADable.`, the last word of the sentence `It may be
  nonREADable.`, the following @RAW-NAMEs are considered until one is
  found with a definition:

  1. The entire word, `"nonREADable."`.

  2. Trimming left does not produce a new raw name.

  3. Trimming right removes the dot and gives `"nonREADable"`.

  4. Trimming both is the same as trimming right.

  5. No plural markers are found.

  6. The lowercase prefix and suffix is removed around the uppercase
     core, giving `"READ"`. This names an interned symbol which has a
     definition, so `\\M-.` will visit it.

  When @GENERATING-DOCUMENTATION, @AUTOLINKing behaves similarly.""")

(define-glossary-term @word (:title "word")
  "A _word_ is a string from which we want to extract a @NAME. When
  [Navigating][@navigating-in-emacs section], the word is
  `slime-sexp-at-point` or the label of a @MARKDOWN/REFLINK if point
  is over one. Similarly, when @GENERATING-DOCUMENTATION, it is a
  non-empty string between whitespace characters in a docstring or the
  label of a @MARKDOWN/REFLINK.")

(define-glossary-term @raw-name (:title "raw name")
  "A _raw name_ is a string from which a @NAME may be read. Raw names
  correspond to an intermediate parsing step between @WORDs an @NAMEs.
  See @NAMES-IN-RAW-NAMES.")

(define-glossary-term @name (:title "name")
  """A _name_ is a [DRef name][dref::@name]. That is, a symbol or a
  string associated with a definition, whose kind is given by a
  DREF::@LOCATIVE.""")

(define-glossary-term @markdown/reflink
    (:title "Markdown reference link"
     :url "https://daringfireball.net/projects/markdown/syntax#link"))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *name-left-trim* "#<{;\"'`")
  (defparameter *name-right-trim* ",;:.>}\"'`"))



(defsection @raw-names-in-words (:title "Raw Names in Words")
  #.(format nil """From @WORDs, @RAW-NAMEs are parsed by trimming some
  prefixes and suffixes. For a given word, multiple raw names are
  considered in the following order.

  1. The entire word.

  2. Trimming the characters `~A` from the left of the word.

  3. Trimming the characters `~A` from the right of the word.

  4. Trimming both of the previous two at the same time.

  5. From the result of 4., [depluralize function][docstring]

  6. From the result of 4., [trim-uppercase-core function][docstring]
  """ *name-left-trim* *name-right-trim*))

;;; Like FIND-IF, but with @NAMEs.
(defun find-name (fn word &key pass-raw symbols-only trim depluralize)
  (let ((left-trim *name-left-trim*)
        (right-trim *name-right-trim*))
    (flet ((consider (raw name)
             (multiple-value-bind (match extra-value)
                 (if pass-raw
                     (funcall fn raw name)
                     (funcall fn name))
               (when match
                 (return-from find-name (values match extra-value))))))
      (flet ((find-it (raw)
               ;; In the @UNSPECIFIC-LINK case, it is arguable that
               ;; the result set should include definitions with all
               ;; @NAMEs found in RAW. However, in the @SPECIFIC-LINK
               ;; case, we must stop at the first match to keep the
               ;; result set size at most 1 (i.e. "specific"), so we
               ;; stop at the first name always for consistency.
               (map-names-in-raw #'consider raw symbols-only)))
        (find-it word)
        (if trim
            (let* ((left-trimmed (string-left-trim left-trim word))
                   (right-trimmed (string-right-trim right-trim word))
                   (both-trimmed
                     (string-right-trim right-trim left-trimmed)))
              (unless (string= left-trimmed word)
                (find-it left-trimmed))
              (unless (string= right-trimmed word)
                (find-it right-trimmed))
              (unless (or (string= both-trimmed left-trimmed)
                          (string= both-trimmed right-trimmed))
                (find-it both-trimmed))
              (when depluralize
                (dolist (depluralized (depluralize both-trimmed))
                  (unless (string= depluralized both-trimmed)
                    (find-it depluralized))))
              (when-let (trimmed (trim-uppercase-core both-trimmed))
                (find-it trimmed)))
            (when depluralize
              (dolist (depluralized (depluralize word))
                (unless (string= depluralized word)
                  (find-it depluralized)))))))))

(defsection @names-in-raw-names (:title "Names in Raw Names")
  """For each @RAW-NAME from @RAW-NAMES-IN-WORDS, various @NAMEs
  may be considered until one is found suitable in the context.

  The following examples list the names considered for a given raw
  name, assuming that READTABLE-CASE is :UPCASE as well as that `FOO`
  and `|Foo|` are interned.

  - `"foo"`: `FOO`, `"foo"`, `"FOO"` (rules 1, 2, 3)

  - `"FOO"`: `FOO`, `"FOO"` (rules 1, 2)

  - `"Foo"`: `"Foo"`, `"FOO"` (rules 2, 3)

  - `"|Foo|"`: `|Foo|` (rule 4)

  - `"\"foo\""`: `"foo"` (rule 5)

  The rules are:

  1. If the raw name is not mixed case (i.e. it doesn't have both
     upper- and lowercase characters) and it names an interned
     symbol (subject to the current @PACKAGE-AND-READTABLE), then that
     symbol is considered as a name.

  2. The raw name itself (a string) is considered a name.

  3. The raw name upcased or downcased according to
     READTABLE-CASE (subject to the [current
     readtable][@package-and-readtable]) but still as a string. This
     is to allow `[dref][package]` to refer to the `"DREF"`
     package regardless of whether the symbol `\DREF` is interned in
     the current package.

  4. If the raw name is explicitly a symbol (it starts with `#\|`),
     and it names an interned symbol (subject to the current
     @PACKAGE-AND-READTABLE), then that symbol is considered as a name
     and nothing else.

  5. If the raw name has an embedded string (it starts with `#\"`) and
     READ-FROM-STRING can read the embedded string from it, then that
     string is considered as a name and nothing else.""")

(defun map-names-in-raw (fn raw symbols-only)
  (flet ((try-parse-symbol (raw)
           (multiple-value-bind (symbol found)
               ;; KLUDGE: (SWANK::PARSE-SYMBOL "PAX:SECTION:")
               ;; incorrectly ignores the trailing colon.
               (unless (ends-with #\: raw)
                 (swank::parse-symbol raw))
             (when found
               (funcall fn raw symbol)))))
    (unless (zerop (length raw))
      (cond ((starts-with #\| raw)
             (try-parse-symbol raw))
            ((and (starts-with #\" raw)
                  (ignore-errors (read-from-string raw)))
             (funcall fn raw (read-from-string raw)))
            (t
             (unless (mixed-case-p raw)
               (try-parse-symbol raw))
             (unless symbols-only
               (funcall fn raw raw)
               (let ((adjusted (dref::adjust-string-case raw)))
                 (when (string/= adjusted raw)
                   (funcall fn raw adjusted)))))))))

(defun depluralize (string)
  "If a @WORD ends with what looks like a plural marker (case-insensitive),
  then a @NAME is created by removing it. For example, from the word
  `BUSES` the plural marker `ES` is removed to produce the name `BUS`.
  The list of plural markers considered is `SES` (e.g. `GASSES`),
  `ES` (e.g. `BUSES`), `S` (e.g. `\\CARS`), `ZES` (e.g. `FEZZES`), and
  `REN` (e.g. `CHILDREN`)."
  ;; Mostly following https://www.grammarly.com/blog/plural-nouns/ but
  ;; keeping only the rules that remove suffixes (e.g. cities -> city
  ;; is not allowed) because that would result in `CITY`s, which looks
  ;; bad.
  (let ((l (length string))
        (r ()))
    (labels ((suffixp (suffix)
               (ends-with-subseq suffix string :test #'char-equal))
             (%desuffix (suffix)
               (subseq string 0 (- l (length suffix))))
             (desuffix (suffix)
               (when (suffixp suffix)
                 (push (%desuffix suffix) r))))
      (desuffix "ses")
      (desuffix "es")
      (desuffix "s")
      (desuffix "zes")
      (desuffix "ren")
      r)))

(defun uppercase-core-bounds (string)
  (let* ((first-uppercase-pos (position-if #'upper-case-p string))
         (last-uppercase-pos (position-if #'upper-case-p string
                                          :from-end t)))
    (when (and first-uppercase-pos
               (if (= last-uppercase-pos first-uppercase-pos)
                   (notany #'lower-case-p string)
                   (not (find-if #'lower-case-p string
                                 :start (1+ first-uppercase-pos)
                                 :end last-uppercase-pos))))
      (values first-uppercase-pos (1+ last-uppercase-pos)))))

(defun trim-uppercase-core (string)
  "removing the prefix before the first, and the suffix after the last
  uppercase character if it contains at least one lowercase character."
  (multiple-value-bind (uppercase-start uppercase-end)
      (uppercase-core-bounds string)
    (when uppercase-start
      ;; If there is no lowercase character before the first, then
      ;; don't trim anything. This prevents %FOO -> FOO.
      (unless (find-if #'lower-case-p string :end uppercase-start)
        (setq uppercase-start 0))
      (unless (find-if #'lower-case-p string :start uppercase-end)
        (setq uppercase-end nil))
      (when (or (plusp uppercase-start) uppercase-end)
        (subseq string uppercase-start uppercase-end)))))


;;; Read a locative form a markdown docstring for DOCUMENT or for M-.
;;; from an Emacs buffer with strange stuff in it.
(defun parse-locative/noisy (string &key junk-allowed)
  (parse-locative
   ;; It is assumed that names of locative types are not funny, and we
   ;; can trim aggressively.
   (string-left-trim *name-left-trim*
                     (string-right-trim *name-right-trim* string))
   :junk-allowed junk-allowed))

;;; Parse "LOCATIVE-TYPE" and "(LOCATIVE-TYPE ...)" like
;;; READ-FROM-STRING, but try to minimize the chance of interning
;;; junk. That is, don't intern LOCATIVE-TYPE (it must be already) or
;;; anything in "..." if LOCATIVE-TYPE is not a valid locative type.
(defun parse-locative (string &key junk-allowed (read-args t))
  (handler-case
      (multiple-value-bind (symbol pos)
          (handler-case
              (read-interned-symbol-from-string string)
            ((or reader-error end-of-file) ()
              nil))
        (if pos
            (when (and (or junk-allowed
                           (not (find-if-not #'whitespacep string :start pos)))
                       (dref symbol 'locative nil))
              (values symbol pos))
            (let ((first-char-pos (position-if-not #'whitespacep string)))
              (when (and first-char-pos (char= (elt string first-char-pos) #\())
                ;; Looks like a list. The first element must be an
                ;; interned symbol naming a locative.
                (let ((delimiter-pos (position-if #'delimiterp string
                                                  :start (1+ first-char-pos))))
                  (multiple-value-bind (symbol found)
                      (swank::parse-symbol
                       (subseq string (1+ first-char-pos) delimiter-pos))
                    (when (and found (dref symbol 'locative nil))
                      (if read-args
                          ;; The rest of the symbols in the string
                          ;; need not be already interned, so let's
                          ;; just READ.
                          (multiple-value-bind (locative position)
                              (ignore-errors (read-from-string string))
                            (when locative
                              (values locative position)))
                          symbol))))))))
    ((or reader-error end-of-file) ()
      nil)))

(defun read-locative-type-from-string (string &key (start 0))
  (multiple-value-bind (symbol pos)
      (read-interned-symbol-from-string string :start start)
    (when (and pos (dref symbol 'locative nil))
      (values symbol pos))))

(defun delimiterp (char)
  (or (whitespacep char) (find char "()'`\"")))
