(in-package :mgl-pax-test)

(deftest test-util ()
  (test-relativize-pathname)
  (test-parse-sexp)
  (test-skip-string-ignoring-case-and-whitespace))

(deftest test-relativize-pathname ()
  (dolist (*default-pathname-defaults*
           (list (make-pathname :directory '(:absolute))
                 (make-pathname)))
    (is (equal (namestring (pax::relativize-pathname "a/b" "x"))
               "a/b"))
    (is (equal (namestring (pax::relativize-pathname "x" "a/b"))
               "../x"))
    (is (equal (namestring (pax::relativize-pathname "a/b/c" "a/x"))
               "b/c"))
    (is (equal (namestring (pax::relativize-pathname "a/x" "a/b/c"))
               "../x"))
    (is (equal (namestring (pax::relativize-pathname "a/b/c" "a/x/y"))
               "../b/c"))
    (is (equal (namestring (pax::relativize-pathname "a/x/y" "a/b/c"))
               "../x/y"))
    (is (equal (namestring (pax::relativize-pathname "a/b/c" "a/x/y/"))
               "../../b/c"))))

(deftest test-parse-sexp ()
  (match-values (pax::parse-sexp "(1 (print \"hey\") #.(find-package :dref))")
    (equal * `(1 (print "hey") ,(find-package :dref)))
    (eql * 40))
  (let ((obj (pax::parse-sexp "#:xxx")))
    (is (symbolp obj))
    (is (null (symbol-package obj)))
    (is (equal (symbol-name obj) (symbol-name '#:xxx))))
  (let ((d (dref 'print 'function))
        (*package* (find-package :mgl-pax-test)))
    (pax::parse-sexp "#<DREF PRINT FUNCTION>"
                     :on-unreadable (alexandria:rcurry #'pax::read-unreadable
                                                       (list d))))
  (signals (pax::parse-sexp-error :pred "EOF")
    (pax::parse-sexp ""))
  (signals (pax::parse-sexp-error :pred "EOF")
    (pax::parse-sexp "("))
  (signals (pax::parse-sexp-error :pred "Unmatched closing")
    (pax::parse-sexp ")"))
  (signals (pax::parse-sexp-error :pred "Junk")
    (pax::parse-sexp "1 x"))
  (let* ((unreadable (find-package :cl))
         (s (format nil "~S1" unreadable)))
    (multiple-value-bind (obj pos)
        (pax::parse-sexp s :junk-allowed t
                           :on-unreadable (lambda (stream)
                                            (pax::read-unreadable
                                             stream (list unreadable))))
      (is (eq obj unreadable))
      (is (eql pos (1- (length s)))))
    (signals (parse-error :pred "Unrecognized unreadable")
      (pax::parse-sexp s :junk-allowed t
                         :on-unreadable (lambda (stream)
                                          (pax::read-unreadable
                                           stream ())))))
  (signals (pax::parse-sexp-error)
    (pax::parse-sexp "#.(mgl-pax-test::junk)" :errorp t)))

(deftest test-skip-string-ignoring-case-and-whitespace ()
  (is (with-input-from-string (s "#<x y>")
        (mgl-pax::skip-string-ignoring-case-and-whitespace s "#<x  y>")))
  (is (not (with-input-from-string (s "#<xy>")
             (mgl-pax::skip-string-ignoring-case-and-whitespace s "#<x y>"))))
  (is (not (with-input-from-string (s "#<x>")
             (mgl-pax::skip-string-ignoring-case-and-whitespace s "#<y>")))))
