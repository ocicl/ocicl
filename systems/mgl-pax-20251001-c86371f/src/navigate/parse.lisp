(in-package :mgl-pax)

(in-readtable pythonic-string-syntax)

(defsection @parsing (:title "Parsing")
  (@parsing-names section)
  (@parsing-locatives section))

(defsection @parsing-names (:title "Parsing Names")
  "When encountering a @WORD such as `CLASSes` in a docstring, PAX
  needs to find the @NAME, and how that's done varies slightly.
  @CODIFICATION, for example, looks for @INTERESTING names,
  @NAVIGATING-IN-EMACS for names with [Lisp][lisp-locative-types
  function] DEFINITIONS, and @LINKING for names with [any kind of
  definition][locative-types function].

  This is not as straightforward as it sounds because it needs to
  handle cases like nonREADable, PRINTed, and all the various forms of
  @LINKING in docstrings as well as in comments, and the `(NAME
  LOCATIVE)` syntax in DEFSECTION."
  (@word glossary-term)
  (@raw-name glossary-term)
  (@name glossary-term)
  "Depending on the context, trimming and depluralization may be
  enabled (see @RAW-NAMES-IN-WORDS), while the possible names may be
  restricted to symbols (see @NAMES-IN-RAW-NAMES).

  - _Trimming:_ Enabled for @M-.-DEFAULTING and @CODIFICATION.

  - _Depluralization:_ Enabled when the @WORD is part of the normal
    flow of text (i.e. not for @SPECIFIC-REFLINK-WITH-TEXT,
    @UNSPECIFIC-REFLINK-WITH-TEXT and various Elisp functions such as
    `mgl-pax-apropos` unless they determine their argument from buffer
    contents).

  - _Symbols only:_ This is the case for @CODIFICATION and
    @UNSPECIFIC-AUTOLINK to prevent string-based definitions from
    littering the documentation with links without the control
    provided by explicitly IMPORTing symbols."
  "For a word, a number of @RAW-NAMEs is generated by trimming
  delimiter characters and plural markers, and for each raw name a
  number of names are considered until one is found suitable in the
  context. The following subsections describe the details of the
  parsing algorithm."
  (@raw-names-in-words section)
  (@names-in-raw-names section)
  """<br/>
  For example, when `\\M-.` is pressed while point is over
  `nonREADable.`, the last word of the sentence `It may be
  nonREADable.`, the following @RAW-NAMEs are considered until one is
  found with a definition:

  1. The entire word, `"nonREADable."`.

  2. Trimming left does not produce a new raw name.

  3. Trimming right removes the dot and gives `"nonREADable"`.

  4. Trimming both is the same as trimming right.

  5. No plural markers are found.

  6. The lowercase prefix and suffix is removed around the uppercase
     core, giving `"READ"`. This names an interned symbol which has a
     definition, so `\\M-.` will visit it.

  When @GENERATING-DOCUMENTATION, @AUTOLINKing behaves similarly.""")

(define-glossary-term @word (:title "word")
  "A _word_ is a string from which we want to extract a @NAME. When
  [Navigating][@navigating-in-emacs section], the word is
  `slime-sexp-at-point` or the label of a @MARKDOWN/REFLINK if point
  is over one. Similarly, when @GENERATING-DOCUMENTATION, it is a
  non-empty string between whitespace characters in a docstring or the
  label of a @MARKDOWN/REFLINK.")

(define-glossary-term @raw-name (:title "raw name")
  "A _raw name_ is a string from which a @NAME may be read. Raw names
  correspond to an intermediate parsing step between @WORDs an @NAMEs.
  See @NAMES-IN-RAW-NAMES.")

(define-glossary-term @name (:title "name")
  """A _name_ is a [DRef name][dref::@name]. That is, a symbol, a
  string or a nested list of the previous associated with a
  definition, whose kind is given by a DREF::@LOCATIVE.""")

(define-glossary-term @markdown/reflink
    (:title "Markdown reference link"
     :url "https://daringfireball.net/projects/markdown/syntax#link"))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *name-left-trim* "#<{;\"'`")
  (defparameter *name-right-trim* ",;:.>}\"'`"))



(defsection @raw-names-in-words (:title "Raw Names in Words")
  #.(format nil """From @WORDs, @RAW-NAMEs are parsed by trimming some
  prefixes and suffixes. For a given word, multiple raw names are
  considered in the following order.

  1. The entire word.

  2. Trimming the following characters from the left of the word:

          ~A

  3. Trimming the following characters from the right of the word:

          ~A

  4. Trimming both of the previous two at the same time.

  5. From the result of 4., [depluralize function][docstring]

  6. From the result of 4., [trim-uppercase-core function][docstring]
  """ *name-left-trim* *name-right-trim*))

;;; Like FIND-IF, but with @NAMEs.
(defun find-name (fn word &key pass-raw symbols-only trim depluralize)
  (let ((left-trim *name-left-trim*)
        (right-trim *name-right-trim*))
    (flet ((consider (raw name)
             (multiple-value-bind (match extra-value)
                 (if pass-raw
                     (funcall fn raw name)
                     (funcall fn name))
               (when match
                 (return-from find-name (values match extra-value))))))
      (flet ((find-it (raw)
               ;; In the @UNSPECIFIC-LINK case, it is arguable that
               ;; the result set should include definitions with all
               ;; @NAMEs found in RAW. However, in the @SPECIFIC-LINK
               ;; case, we must stop at the first match to keep the
               ;; result set size at most 1 (i.e. "specific"), so we
               ;; stop at the first name always for consistency.
               (map-names-in-raw #'consider raw symbols-only)))
        (find-it word)
        (if trim
            (let* ((left-trimmed (string-left-trim left-trim word))
                   (right-trimmed (string-right-trim right-trim word))
                   (both-trimmed
                     (string-right-trim right-trim left-trimmed)))
              (unless (string= left-trimmed word)
                (find-it left-trimmed))
              (unless (string= right-trimmed word)
                (find-it right-trimmed))
              (unless (or (string= both-trimmed left-trimmed)
                          (string= both-trimmed right-trimmed))
                (find-it both-trimmed))
              (when depluralize
                (dolist (depluralized (depluralize both-trimmed))
                  (unless (string= depluralized both-trimmed)
                    (find-it depluralized))))
              (when-let (trimmed (trim-uppercase-core both-trimmed))
                (find-it trimmed)))
            (when depluralize
              (dolist (depluralized (depluralize word))
                (unless (string= depluralized word)
                  (find-it depluralized)))))))))

(defsection @names-in-raw-names (:title "Names in Raw Names")
  """For each @RAW-NAME from @RAW-NAMES-IN-WORDS, various @NAMEs
  may be considered until one is found that's suitable in the context.

  The following examples list the names considered for a given raw
  name, assuming that READTABLE-CASE is :UPCASE as well as that `FOO`
  and `|Foo|` are interned.

  - `"foo"`: `FOO`, `"foo"`, `"FOO"` (rules 1, 2, 3)

  - `"FOO"`: `FOO`, `"FOO"` (rules 1, 2)

  - `"Foo"`: `"Foo"`, `"FOO"` (rules 2, 3)

  - `"|Foo|"`: `|Foo|` (rule 4)

  - `"\"foo\""`: `"foo"` (rule 5)

  The rules are:

  1. If the raw name is not mixed case (i.e. it doesn't have both
     upper- and lowercase characters) and it names an interned
     symbol (subject to the current @PACKAGE-AND-READTABLE), then that
     symbol is considered as a name.

  2. The raw name itself (a string) is considered a name.

  3. The raw name upcased or downcased according to
     READTABLE-CASE (subject to the [current
     readtable][@package-and-readtable]) but still as a string. This
     is to allow `[dref][package]` to refer to the `"DREF"`
     package regardless of whether the symbol `\DREF` is interned in
     the current package.

  4. If the raw name is explicitly a symbol (it starts with `#\|`),
     and it names an interned symbol (subject to the current
     @PACKAGE-AND-READTABLE), then that symbol is considered as a name
     and nothing else.

  5. If the raw name has an embedded string (it starts with `#\"`) and
     READ-FROM-STRING can read the embedded string from it, then that
     string is considered as a name and nothing else.""")

(defun map-names-in-raw (fn raw symbols-only)
  (flet ((try-parse-sexp (raw)
           (multiple-value-bind (symbol foundp) (parse-sexp raw :errorp nil)
             (when foundp
               (funcall fn raw symbol))))
         (try-parse-symbol (raw)
           (multiple-value-bind (symbol foundp) (parse-interned-symbol raw)
             (when foundp
               (funcall fn raw symbol)))))
    (unless (zerop (length raw))
      (cond ((find (aref raw 0) "|\"(")
             (try-parse-sexp raw))
            (t
             (unless (mixed-case-p raw)
               (try-parse-symbol raw))
             (unless symbols-only
               (funcall fn raw raw)
               (let ((adjusted (dref::adjust-string-case raw)))
                 (when (string/= adjusted raw)
                   (funcall fn raw adjusted)))))))))

(defun depluralize (string)
  "If a @WORD ends with what looks like a plural marker (case-insensitive),
  then a @NAME is created by removing it. For example, from the word
  `BUSES` the plural marker `ES` is removed to produce the name `BUS`.
  The list of plural markers considered is `SES` (e.g. `GASSES`),
  `ES` (e.g. `BUSES`), `S` (e.g. `\\CARS`), `ZES` (e.g. `FEZZES`), and
  `REN` (e.g. `CHILDREN`)."
  ;; Mostly following https://www.grammarly.com/blog/plural-nouns/ but
  ;; keeping only the rules that remove suffixes (e.g. cities -> city
  ;; is not allowed) because that would result in `CITY`s, which looks
  ;; bad.
  (let ((l (length string))
        (r ()))
    (labels ((suffixp (suffix)
               (ends-with-subseq suffix string :test #'char-equal))
             (%desuffix (suffix)
               (subseq string 0 (- l (length suffix))))
             (desuffix (suffix)
               (when (suffixp suffix)
                 (push (%desuffix suffix) r))))
      (desuffix "ses")
      (desuffix "es")
      (desuffix "s")
      (desuffix "zes")
      (desuffix "ren")
      r)))

(defun uppercase-core-bounds (string)
  (let* ((first-uppercase-pos (position-if #'upper-case-p string))
         (last-uppercase-pos (position-if #'upper-case-p string
                                          :from-end t)))
    (when (and first-uppercase-pos
               (if (= last-uppercase-pos first-uppercase-pos)
                   (notany #'lower-case-p string)
                   (not (find-if #'lower-case-p string
                                 :start (1+ first-uppercase-pos)
                                 :end last-uppercase-pos))))
      (values first-uppercase-pos (1+ last-uppercase-pos)))))

(defun trim-uppercase-core (string)
  "removing the prefix before the first, and the suffix after the last
  uppercase character if it contains at least one lowercase character."
  (multiple-value-bind (uppercase-start uppercase-end)
      (uppercase-core-bounds string)
    (when uppercase-start
      ;; If there is no lowercase character before the first, then
      ;; don't trim anything. This prevents %FOO -> FOO.
      (unless (find-if #'lower-case-p string :end uppercase-start)
        (setq uppercase-start 0))
      (unless (find-if #'lower-case-p string :start uppercase-end)
        (setq uppercase-end nil))
      (when (or (plusp uppercase-start) uppercase-end)
        (subseq string uppercase-start uppercase-end)))))


(defsection @parsing-locatives (:title "Parsing Locatives")
  """Locatives are parsed almost as if by READ. They are found in
  buffer contents around a @WORD when @M-.-DEFAULTING or
  @GENERATING-DOCUMENTATION, and in the string entered when
  @M-.-PROMPTING, with a similar distinction when
  @BROWSING-LIVE-DOCUMENTATION.

  Parsing deviates from READ in the following ways.

  - No new symbols are INTERNed during parsing. If an expression
    contains uninterned symbols, then it is not parsable as a
    locative.

  - Read-time evaluation ([#.][clhs]) follows normal READ semantics.
    Thus, `(method ((eql #.(find-package 'cl))))` may INTERN the
    symbol `CL`.

  - A locative that involves unreadable objects that print using the
    `#<` syntax (e.g. `(METHOD ((EQL #<PACKAGE DREF>)))`) is parsable
    in the context of a @NAME if each unreadable object in the
    locative occurs in one of the DEFINITIONS of that name and it
    @PRINTS-TO-AN-EQUIVALENT-STRING (e.g. `#<PACKAGE DREF>` above)."""
  (@prints-to-an-equivalent-string glossary-term))

(define-glossary-term @prints-to-an-equivalent-string
    (:title "prints to an equivalent string")
  "@UNREADABLE-PRINTS-TO

  See the related concept of @STABLE-PRINTED-LOCATIVE, that requires
  the printed representation of entire locatives to be unique and
  non-changing to support @LINKING.")

;;; Parse "LOCATIVE-TYPE" and "(LOCATIVE-TYPE ...)" like
;;; READ-FROM-STRING, but do not intern anything. Also, return NIL if
;;; the locative type parsed is not defined. If ERRORP, then
;;; PARSE-ERROR may be signalled.
(defun parse-locative (string &key junk-allowed (errorp nil)
                                (on-unreadable :error) (name 'no-name))
  (multiple-value-bind (locative pos)
      (parse-sexp string :junk-allowed junk-allowed :errorp errorp
                         :on-unreadable (if (eq name 'no-name)
                                            on-unreadable
                                            (make-unreadable-reader name)))
    (let ((locative-type (locative-type locative)))
      (if (dref locative-type 'locative nil)
          (values locative pos)
          (when errorp
            (dref::invalid-locative-type locative-type))))))

(defun make-unreadable-reader (name)
  (let ((unreadables :uninitialized))
    (lambda (stream)
      (note @unreadable-locative-parsing
        "Unreadable objects in the locative strings are identified by
        comparing their PRIN1 representation (under
        WITH-STANDARD-IO-SYNTAX but in the current package and with
        *PRINT-READABLY* NIL) to the relevant substring."
        (when (eq unreadables :uninitialized)
          (setq unreadables
                (potentially-unreadable-objects-in-locatives name)))
        (note
          "[@WHITESPACE-MULTIPLICITY NOTE][docstring]"
          (read-unreadable stream unreadables))))))

(defun potentially-unreadable-objects-in-locatives (name)
  (loop for dref in (definitions name)
        append (flatten (dref-locative-args dref))))

;;; Read a locative form a Markdown docstring in the vicinity of some
;;; NAME for DOCUMENT or for M-. from an Emacs buffer with strange
;;; stuff in it.
(defun parse-locative-around (string &key junk-allowed (errorp nil)
                                       (on-unreadable :error)
                                       (name 'no-name))
  (parse-locative
   ;; It is assumed that names of locative types are not funny, and we
   ;; can trim aggressively.
   (string-left-trim *name-left-trim*
                     (string-right-trim *name-right-trim* string))
   :junk-allowed junk-allowed :errorp errorp
   :on-unreadable on-unreadable :name name))

(defun validate-parsed-locative-type (string)
  (let ((locative (parse-sexp string :errorp nil :on-unreadable :truncate)))
    (dref (locative-type locative) 'locative nil)))

(defun read-locative-type-from-string (string &key (start 0))
  (multiple-value-bind (symbol foundp pos)
      (parse-interned-symbol string :start start)
    (when (and foundp (dref symbol 'locative nil))
      (values symbol pos))))
