# DRef Manual

###### [in package DREF]

## Links and Systems

Here is the [official
repository](https://github.com/melisgl/mgl-pax/dref) and the [HTML
documentation](http://melisgl.github.io/mgl-pax-world/dref-manual.html)
for the latest version.

DRef is bundled in the same repository with PAX,
the documentation system.

- [system] "dref"

    - Version: 0.4.4

    - Description: Reify definitions, provide portable access to
    docstrings and source locations in an extensible framework.

    - Long Description: DEFUN defines a first-class object: a FUNCTION.
    DEFVAR does not. This library provides a way to refer to all
    definitions and smooths over the differences between
    implementations. This system has minimal dependencies. It autoloads
    the dref/full ASDF:SYSTEM, which depends Alexandria and Swank.

    - Licence: MIT, see COPYING.

    - Author: GÃ¡bor Melis

    - Mailto: [mega@retes.hu](mailto:mega@retes.hu)

    - Homepage: [http://github.com/melisgl/mgl-pax/tree/master/dref](http://github.com/melisgl/mgl-pax/tree/master/dref)

    - Bug tracker: [https://github.com/melisgl/mgl-pax/issues](https://github.com/melisgl/mgl-pax/issues)

    - Source control: [GIT](https://github.com/melisgl/mgl-pax.git)

    - Depends on: autoload, mgl-pax-bootstrap, named-readtables, pythonic-string-reader

    - Defsystem depends on: mgl-pax.asdf

- [system] "dref/full"

    - Description: DREF with everything loaded. There should be no need
    to explicitly load this system (or depend on it) as it is autoloaded
    as necessary by all publicly accessible functionality in DREF.

        However, to get the dependencies, install this system.

    - Depends on: alexandria, dref, swank(?)

    - Defsystem depends on: mgl-pax.asdf

## Introduction

What if definitions were first-class objects?

Some defining forms do not create first-class
objects. For example, DEFUN creates
FUNCTION objects, but DEFVAR does not create variable
objects as no such thing exists. The main purpose of this library is
to fill this gap with the introduction of DREF objects:

    (defvar *my-var* nil
      "This is my var.")
    (dref '*my-var* 'variable)
    ==> #<DREF *MY-VAR* VARIABLE>

DREFs just package up a name (*MY-VAR*) and a
locative (VARIABLE) then check that the definition
actually exists:

    (dref 'junk 'variable)
    .. debugger invoked on LOCATE-ERROR:
    ..   Could not locate JUNK VARIABLE.

The Basic Operations on definitions in DRef are ARGLIST, DOCSTRING
and SOURCE-LOCATION.

    (docstring (dref '*my-var* 'variable))
    => "This is my var."

For definitions associated with objects, the definition can be
LOCATEd from the object:

    (locate #'print)
    ==> #<DREF PRINT FUNCTION>

These objects designate their definitions, so (DOCSTRING #'PRINT)
works. Extending DRef and these operations is possible through
Defining Locative Types. It is also possible to define
new operations. For example, PAX makes
PAX:DOCUMENT extensible through PAX:DOCUMENT-OBJECT*.

Finally, existing definitions can be queried with DEFINITIONS and
DREF-APROPOS:

    (definitions 'dref-ext:arglist*)
    ==> (#<DREF ARGLIST* GENERIC-FUNCTION>
    -->  #<DREF ARGLIST* (METHOD (MGL-PAX::GO-DREF))>
    -->  #<DREF ARGLIST* (METHOD (LAMBDA-DREF))>
    -->  #<DREF ARGLIST* (METHOD (TYPE-DREF))>
    -->  #<DREF ARGLIST* (METHOD (METHOD-DREF))>
    -->  #<DREF ARGLIST* (METHOD (FUNCTION-DREF))>
    -->  #<DREF ARGLIST* (METHOD (COMPILER-MACRO-DREF))>
    -->  #<DREF ARGLIST* (METHOD (MACRO-DREF))>
    -->  #<DREF ARGLIST* (METHOD (SETF-DREF))> #<DREF ARGLIST* (METHOD (T))>
    -->  #<DREF ARGLIST* (METHOD (DREF))>
    -->  #<DREF ARGLIST* (UNKNOWN
    -->                   (DECLAIM ARGLIST*
    -->                            FTYPE))>)

    (dref-apropos 'locate-error :package :dref)
    ==> (#<DREF LOCATE-ERROR CONDITION> #<DREF LOCATE-ERROR FUNCTION>)
    
    (dref-apropos "ate-err" :package :dref :external-only t)
    ==> (#<DREF LOCATE-ERROR CONDITION> #<DREF LOCATE-ERROR FUNCTION>)

## References

After the Introduction, here we get into the details. Of special
interest are:

- The XREF function to construct an arbitrary reference without any
  checking of validity.

- LOCATE and DREF to look up the definition of an
  object (e.g #'PRINT) or a reference (e.g. (XREF 'PRINT
  'FUNCTION)).

- RESOLVE to find the first-class (non-XREF) object the
  definition refers to, if any.

The Basic Operations (ARGLIST, DOCSTRING, SOURCE-LOCATION) know how to
deal with references (discussed in the Extending DRef).

- [class] XREF

    An XREF (cross-reference) is a reference. It may
    represent some kind of definition of its name in the context given
    by its locative. The definition may not exist and the locative may
    even be invalid. The subclass DREF represents
    definitions that exist.

- [function] XREF NAME LOCATIVE

    A shorthand for (MAKE-INSTANCE 'XREF :NAME NAME :LOCATIVE LOCATIVE)
    to create XREF objects. It does no error checking: the
    LOCATIVE-TYPE of LOCATIVE-TYPE need not be defined, and the
    LOCATIVE-ARGS need not be valid. Use LOCATE or the DREF function to
    create DREF objects.

- [function] XREF= XREF1 XREF2

    See if XREF1 and XREF2 have the same XREF-NAME and XREF-LOCATIVE
    under EQUAL. Comparing like this makes most sense for
    DREFs. However, two XREFs different under XREF=
    may denote the same DREFs.

- [class] DREF XREF

    DREFs can be thought of as definitions that
    actually exist, although changes in the system can invalidate
    them (for example, a DREF to a function definition can be
    invalidated by FMAKUNBOUND). DREFs must be created with LOCATE or
    the DREF function.

    Two DREFs created in the same dynamic environment denote the
    same thing if and only if they are XREF=.

- [function] LOCATE OBJECT &OPTIONAL (ERRORP T)

    Return a DREF representing the definition of OBJECT.

    OBJECT must be a supported first-class object, a DREF, or an
    XREF:

        (locate #'print)
        ==> #<DREF PRINT FUNCTION>

        (locate (locate #'print))
        ==> #<DREF PRINT FUNCTION>

        (locate (xref 'print 'function))
        ==> #<DREF PRINT FUNCTION>

    When OBJECT is a DREF, it is simply returned.

    Else, a LOCATE-ERROR is signalled if OBJECT is an XREF with an
    invalid locative, or if no corresponding definition is found. If
    ERRORP is NIL, then NIL is returned instead.

        (locate (xref 'no-such-function 'function))
        .. debugger invoked on LOCATE-ERROR:
        ..   Could not locate NO-SUCH-FUNCTION FUNCTION.
        ..   NO-SUCH-FUNCTION does not name a function.

        (locate (xref 'print '(function xxx)))
        .. debugger invoked on LOCATE-ERROR:
        ..   Could not locate PRINT #'XXX.
        ..   Bad arguments (XXX) for locative FUNCTION with lambda list NIL.

        (locate "xxx")
        .. debugger invoked on LOCATE-ERROR:
        ..   Could not locate "xxx".

    Use the XREF function to construct an XREF without error checking.

    See Extending LOCATE.

- [function] DREF NAME LOCATIVE &OPTIONAL (ERRORP T)

    Shorthand for (LOCATE (XREF NAME LOCATIVE) ERRORP).

- [function] RESOLVE OBJECT &OPTIONAL (ERRORP T)

    If OBJECT is an XREF, then return the first-class object
    associated with its definition if any. Return OBJECT if it's not an
    XREF. Thus, the value returned is never an XREF. The second return
    value is whether resolving succeeded.

        (resolve (dref 'print 'function))
        ==> #<FUNCTION PRINT>
        => T

        (resolve #'print)
        ==> #<FUNCTION PRINT>
        => T

    If OBJECT is an XREF, and the definition for it cannot be LOCATEd,
    then LOCATE-ERROR is signalled.

        (resolve (xref 'undefined 'variable))
        .. debugger invoked on LOCATE-ERROR:
        ..   Could not locate UNDEFINED VARIABLE.

    If there is a definition, but there is no first-class object
    corresponding to it, then RESOLVE-ERROR is signalled or NIL is
    returned depending on ERRORP:

        (resolve (dref '*print-length* 'variable))
        .. debugger invoked on RESOLVE-ERROR:
        ..   Could not resolve *PRINT-LENGTH* VARIABLE.

        (resolve (dref '*print-length* 'variable) nil)
        => NIL
        => NIL

    RESOLVE is a partial inverse of LOCATE: if a DREF is
    RESOLVEable, then LOCATEing the object it resolves to recovers the
    DREF equivalent to the original (XREF= and of the same type but not
    EQ).

    Can be extended via RESOLVE*.

- [condition] LOCATE-ERROR ERROR

    Signalled by LOCATE when the definition cannot be
    found, and ERRORP is true.

- [condition] RESOLVE-ERROR ERROR

    Signalled by RESOLVE when the object defined cannot
    be returned, and ERRORP is true.

### Dissecting References

- [reader] XREF-NAME XREF (:NAME)

    The name of the reference.

- [reader] XREF-LOCATIVE XREF (:LOCATIVE)

    The locative of the reference.

    The locative is normalized by replacing single-element lists with
     their only element:

        (xref 'print 'function)
        ==> #<XREF PRINT FUNCTION>

        (xref 'print '(function))
        ==> #<XREF PRINT FUNCTION>

- [reader] DREF-NAME DREF

    The same as XREF-NAME, but only works on
    DREFs. Use it as a statement of intent.

- [reader] DREF-LOCATIVE DREF

    The same as XREF-LOCATIVE, but only works on
    DREFs. Use it as a statement of intent.

- [reader] DREF-ORIGIN DREF

    The object from which LOCATE constructed this
    DREF. DREF-ORIGIN may have presentation arguments, which
    are not included in LOCATIVE-ARGS as is the case with the INITFORM
    argument of the VARIABLE locative:

        (dref '*standard-output* '(variable "see-below"))
        ==> #<DREF *STANDARD-OUTPUT* VARIABLE>

        (dref-origin (dref '*standard-output* '(variable "see-below")))
        ==> #<XREF *STANDARD-OUTPUT* (VARIABLE "see-below")>

    The INITFORM argument overrides the global binding of
    *STANDARD-OUTPUT* when it's PAX:DOCUMENTed:

        (first-line
         (pax:document (dref '*standard-output* '(variable "see-below"))
                       :stream nil))
        => "- [variable] *STANDARD-OUTPUT* \"see-below\""

- [function] LOCATIVE-TYPE LOCATIVE

    Return locative type of the locative LOCATIVE. This is the first
    element of LOCATIVE if it's a list. If it's a symbol, it's that
    symbol itself.

- [function] LOCATIVE-ARGS LOCATIVE

    Return the REST of locative LOCATIVE if it's a list. If it's a symbol,
    then return NIL. See locative.

The following convenience functions are compositions of
{LOCATIVE-TYPE, LOCATIVE-ARGS} and {XREF-LOCATIVE,
DREF-LOCATIVE}.

- [function] XREF-LOCATIVE-TYPE XREF

- [function] XREF-LOCATIVE-ARGS XREF

- [function] DREF-LOCATIVE-TYPE DREF

- [function] DREF-LOCATIVE-ARGS DREF

### References Glossary

- [glossary-term] reference

    A reference is a name plus a locative, and it identifies a
    possible definition. References are of class XREF. When a reference
    is a DREF, it may also be called a definition.

- [glossary-term] definition

    A definition is a reference that identifies a concrete definition.
    Definitions are of class DREF. A definition RESOLVEs to the
    first-class object associated with the definition if such a thing
    exists, and LOCATE on this object returns the canonical DREF object
    that's unique under XREF=.

    The kind of a definition is given by its locative type. There is at
    most one definition for any given name and locative type.
    Equivalently, there can be no two definitions of the same DREF-NAME
    and DREF-LOCATIVE-TYPE but different DREF-LOCATIVE-ARGS.

- [glossary-term] name

    Names are symbols, strings and nested lists of the previous, which
    name functions, types,
    packages, etc. Together with locatives, they
    form references.

    See XREF-NAME and DREF-NAME.

- [glossary-term] locative

    Locatives specify a type of definition such as
    FUNCTION or VARIABLE. Together with names,
    they form references.

    In their compound form, locatives may have arguments (see
    LOCATIVE-ARGS) as in (METHOD (NUMBER)). In fact, their atomic form
    is shorthand for the common no-argument case: that is, FUNCTION is
    equivalent to (FUNCTION).

    A locative is valid if it names an existing locative type and its
    LOCATIVE-ARGS match that type's lambda-list (see
    DEFINE-LOCATIVE-TYPE).

        (arglist (dref 'method 'locative))
        => (&REST QUALIFIERS-AND-SPECIALIZERS)
        => :DESTRUCTURING

    See XREF-LOCATIVE and DREF-LOCATIVE.

- [glossary-term] locative type

    The locative type is the part of a locative that identifies
    what kind definition is being referred to. This is always a symbol.

    Locative types are defined with DEFINE-LOCATIVE-TYPE or
    DEFINE-PSEUDO-LOCATIVE-TYPE. See Basic Locative Types for the list
    locative types built into DRef, and PAX Locatives for
    those in PAX.

    Also, see LOCATIVE-TYPE, XREF-LOCATIVE-TYPE, DREF-LOCATIVE-TYPE,
    Defining Locative Types.

- [glossary-term] presentation

    references may have arguments (see
    Defining Locative Types) that do not affect the behaviour
    of LOCATE and the Basic Operations, but which may be used for
    other, "presentation" purposes. For example, the VARIABLE
    locative's INITFORM argument is used for presentation by
    PAX:DOCUMENT. Presentation arguments are available via
    DREF:DREF-ORIGIN but do not feature in DREF-LOCATIVE to ensure the
    uniqueness of the definition under XREF=.

## DTYPEs

DTYPEs are to Lisp types what locative types are to CLASSes.
A DTYPE is either

- a locative type such as FUNCTION, TYPE
  and CLHS, or

- a full locative such as (METHOD (NUMBER)) and (CLHS SECTION),
  or

- NIL (the empty DTYPE) and T (that encompasses all
  LISP-LOCATIVE-TYPES), or

- named with DEFINE-DTYPE (such as PSEUDO and TOP), or

- a combination of the above with AND, OR and
  NOT, or

- a MEMBER form with LOCATEable definitions, or

- a SATISFIES form with the name of a function that takes a single
  definition as its argument.

DTYPEs are used in DEFINITIONS and DREF-APROPOS to filter the set of
definitions as in

    (definitions 'print :dtype '(not unknown))
    ==> (#<DREF PRINT (CLHS FUNCTION)> #<DREF PRINT FUNCTION>)

    (dref-apropos "type specifier" :dtype 'pseudo)
    ==> (#<DREF "1.4.4.6" #1=(CLHS SECTION)> #<DREF "1.4.4.6.1" #1#>
    -->  #<DREF "1.4.4.6.2" #1#> #<DREF "1.4.4.6.3" #1#>
    -->  #<DREF "1.4.4.6.4" #1#> #<DREF "4.2.3" #1#>
    -->  #<DREF "atomic type specifier" #2=(CLHS GLOSSARY-TERM)>
    -->  #<DREF "compound type specifier" #2#>
    -->  #<DREF "derived type specifier" #2#> #<DREF "type specifier" #2#>)

- [macro] DEFINE-DTYPE NAME LAMBDA-LIST &BODY BODY

    Like DEFTYPE, but it may expand into other DTYPEs.

    The following example defines METHOD* as the locative METHOD
    without its direct locative subtypes.

        (define-dtype method* () '(and method (not reader) (not writer)))

    See DTYPEP for the semantics and also the locative DTYPE.

- [dtype] TOP

    This is the top of the DTYPE hierarchy, much like T for Lisp types.
    It expands to (OR T PSEUDO). While T matches every normal
    Lisp object and objectless definitions present in the running
    Lisp (see LISP-LOCATIVE-TYPES), TOP matches even pseudo
    definitions (see PSEUDO-LOCATIVE-TYPES).

- [dtype] PSEUDO

    This is the union of all PSEUDO-LOCATIVE-TYPES. It expands
    to (OR ,@(PSEUDO-LOCATIVE-TYPES)).

- [function] DTYPEP DREF DTYPE

    See if DREF is of DTYPE.

    - Atomic locatives: If DTYPE is a locative type,
      then it matches definitions with that locative type and its
      locative subtypes.

        Because CONSTANT is defined with VARIABLE among its
         LOCATIVE-SUPERTYPES:

            (dtypep (dref 'pi 'constant) 'variable)
            => T

            (dtypep (dref 'number 'class) 'type)
            => T

        It is an error if DTYPE is an ATOM but is not a locative type,
        but (the empty) argument list of bare locative types are not
        checked even if having no arguments makes them invalid
        locatives.

    - Compound locatives: Locatives in their compound
      form are validated and must match exactly (under EQUAL, as in
      XREF=).

            (defparameter *d* (dref 'dref* '(method (t t t))))
            (defparameter *d2* (dref 'dref* '(method :around (t t t))))
            (dtypep *d* 'method)
            => T
            (dtypep *d* '(accessor))
            .. debugger invoked on SIMPLE-ERROR:
            ..   Bad arguments NIL for locative ACCESSOR with lambda list (CLASS-NAME).
            (dtypep *d* '(method (t t t)))
            => T
            (dtypep *d2* '(method (t t t)))
            => NIL

    - DTYPE may be constructed with AND, OR and
      NOT from Lisp types, locative types, full locatives and
      named DTYPEs:

            (dtypep (dref 'locate-error 'condition) '(or condition class))
            => T
            (dtypep (dref nil 'type) '(and type (not class)))
            => T

    - For (MEMBER &REST OBJS), each of OBJs is LOCATEd and DREF is
      matched against them with XREF=:

            (dtypep (locate #'print) `(member ,#'print))
            => T

    - For (SATISFIES PRED), the predicate PRED is funcalled with DREF.

    - DTYPE may be named by DEFINE-DTYPE:

            (dtypep (locate #'car) 'top)
            => T

## Listing Definitions

- [function] DEFINITIONS NAME &KEY (DTYPE T)

    List all definitions of NAME that are of DTYPE as DREFs.

    Just as (DREF NAME LOCATIVE) returns the canonical definition, the
    DREF-NAMEs of returned by DEFINITIONS may be different from NAME:

        (definitions "PAX")
        ==> (#<DREF "MGL-PAX" PACKAGE>)

        (definitions 'mgl-pax)
        ==> (#<DREF "mgl-pax" ASDF/SYSTEM:SYSTEM> #<DREF "MGL-PAX" PACKAGE>)

    Similarly, DREF-LOCATIVE-TYPE may be more made more specific:

        (definitions 'dref:locate-error :dtype 'type)
        ==> (#<DREF LOCATE-ERROR CONDITION>)

    Can be extended via MAP-DEFINITIONS-OF-NAME.

- [function] DREF-APROPOS NAME &KEY PACKAGE EXTERNAL-ONLY CASE-SENSITIVE (DTYPE T)

    Return a list of DREFs corresponding to existing
    definitions that match the various arguments. First, (DREF-APROPOS
    NIL) lists all definitions in the running Lisp and maybe more (e.g.
    MGL-PAX:CLHS). Arguments specify how the list of
    definitions is filtered.

    DREF-APROPOS itself is similar to CL:APROPOS-LIST, but

    - it finds definitions not SYMBOLs,

    - it supports an extensible definition types, and

    - filtering based on them.

    PAX has a live browsing frontend.

    Roughly speaking, when NAME or PACKAGE is a SYMBOL, they must match
    the whole name of the definition:

        (dref-apropos 'method :package :dref :external-only t)
        ==> (#<DREF METHOD CLASS> #<DREF METHOD LOCATIVE>)

    On the other hand, when NAME or PACKAGE is a STRING, they are
    matched as substrings to the definition's name PRINC-TO-STRINGed:

        (dref-apropos "method" :package :dref :external-only t)
        ==> (#<DREF SETF-METHOD LOCATIVE> #<DREF METHOD CLASS>
        -->  #<DREF METHOD LOCATIVE> #<DREF METHOD-COMBINATION CLASS>
        -->  #<DREF METHOD-COMBINATION LOCATIVE>)

    Definitions that are not of DTYPE (see DTYPEP) are filtered out:

        (dref-apropos "method" :package :dref :external-only t :dtype 'class)
        ==> (#<DREF METHOD CLASS> #<DREF METHOD-COMBINATION CLASS>)

    When PACKAGE is :NONE, only non-symbol names are matched:

        (dref-apropos "dref" :package :none)
        ==> (#<DREF "DREF" PACKAGE> #<DREF "DREF-EXT" PACKAGE>
        -->  #<DREF "DREF-TEST" PACKAGE> #<DREF "dref" ASDF/SYSTEM:SYSTEM>
        -->  #<DREF "dref/full" ASDF/SYSTEM:SYSTEM>
        -->  #<DREF "dref/test" ASDF/SYSTEM:SYSTEM>
        -->  #<DREF "dref/test-autoload" ASDF/SYSTEM:SYSTEM>)

    The exact rules of filtering are as follows. Let C be the name of
    the candidate definition from the list of all definitions that we
    are matching against the arguments and denote its string
    representation (PRINC-TO-STRING C) with P. Note that
    PRINC-TO-STRING does not print the package of symbols. We say that
    two strings match if CASE-SENSITIVE is NIL and they are EQUALP, or
    CASE-SENSITIVE is true and they are EQUAL. CASE-SENSITIVE affects
    substring comparisons too.

    - If NAME is a SYMBOL, then its SYMBOL-NAME must match P.

    - If NAME is a STRING, then it must be a substring of P.

    - If PACKAGE is :ANY, then C must be a SYMBOL.

    - If PACKAGE is :NONE, then C must not be a SYMBOL.

    - If PACKAGE is not NIL, :ANY or :NONE, then C must be a symbol.

    - If PACKAGE is a PACKAGE, it must be EQ to the
      SYMBOL-PACKAGE of C.

    - If PACKAGE is a SYMBOL other than NIL, :ANY and :NONE, then its
      SYMBOL-NAME must match the PACKAGE-NAME or one of the
      PACKAGE-NICKNAMES of SYMBOL-PACKAGE of C.

    - If PACKAGE is a STRING, then it must be a substring of the
      PACKAGE-NAME of SYMBOL-PACKAGE of C.

    - If EXTERNAL-ONLY and C is a symbol, then C must be external in
      a matching package.

    - DTYPE matches candidate definition D if (DTYPEP D DTYPE).

    Can be extended via MAP-REFERENCES-OF-TYPE and
    MAP-DEFINITIONS-OF-NAME.

- [glossary-term] reverse definition order

    Lists of locative types and aliases are sometimes in reverse order
    of the time of their definition. This order is not affected by
    redefinition, regardless of whether it's by DEFINE-LOCATIVE-TYPE,
    DEFINE-PSEUDO-LOCATIVE-TYPE, DEFINE-SYMBOL-LOCATIVE-TYPE or
    DEFINE-LOCATIVE-ALIAS.

- [function] LOCATIVE-TYPES

    Return a list of non-alias locative types.
    This is the UNION of LISP-LOCATIVE-TYPES and PSEUDO-LOCATIVE-TYPES,
    which is the set of constituents of the DTYPE TOP.

    This list is in reverse definition order.

- [function] LISP-LOCATIVE-TYPES

    Return the locative types that correspond to Lisp definitions,
    which typically have SOURCE-LOCATION. These are defined with
    DEFINE-LOCATIVE-TYPE and DEFINE-SYMBOL-LOCATIVE-TYPE and are the
    constituents of DTYPE T.

    This list is in reverse definition order.

- [function] PSEUDO-LOCATIVE-TYPES

    Return the locative types that correspond to non-Lisp definitions.
    These are the ones defined with DEFINE-PSEUDO-LOCATIVE-TYPE and are
    the constituents of DTYPE PSEUDO.

    This list is in reverse definition order.

- [function] LOCATIVE-ALIASES

    Return the list of locatives aliases, defined with DEFINE-LOCATIVE-ALIAS.

    This list is in reverse definition order.

## Basic Operations

The following functions take a single argument, which may be a
DREF, or an object denoting its own definition (see
LOCATE).

- [function] ARGLIST OBJECT

    Return the arglist of the definition of OBJECT or NIL if the
    arglist cannot be determined.

    The second return value indicates whether the arglist has been
    found. As the second return value, :ORDINARY indicates an ordinary
    lambda list, :MACRO a macro lambda list, :DEFTYPE a
    deftype lambda list, and :DESTRUCTURING a destructuring
    lambda list. Other non-NIL values are also allowed.

        (arglist #'arglist)
        => (OBJECT)
        => :ORDINARY

        (arglist (dref 'define-locative-type 'macro))
        => (LOCATIVE-TYPE-AND-LAMBDA-LIST LOCATIVE-SUPERTYPES &OPTIONAL
            DOCSTRING DREF-DEFCLASS-FORM)
        => :MACRO

        (arglist (dref 'method 'locative))
        => (&REST QUALIFIERS-AND-SPECIALIZERS)
        => :DESTRUCTURING

    This function supports MACROs,
    COMPILER-MACROs, SETF functions,
    FUNCTIONs, GENERIC-FUNCTIONs,
    METHODs, TYPEs, LOCATIVEs. Note
    that ARGLIST depends on the quality of SWANK-BACKEND:ARGLIST. With
    the exception of SBCL, which has perfect support, all Lisp
    implementations have minor omissions:

    - DEFTYPE lambda lists on ABCL, AllegroCL, CLISP, CCL, CMUCL, ECL;

    - default values in MACRO lambda lists on AllegroCL;

    - various edge cases involving traced functions.

    Can be extended via ARGLIST*

- [function] DOCSTRING OBJECT

    Return the docstring from the definition of OBJECT.
    As the second value, return the *PACKAGE* that was in effect when
    the docstring was installed or NIL if it cannot be determined (this
    is used by PAX:DOCUMENT when Parsing the docstring). This
    function is similar in purpose to CL:DOCUMENTATION.

    Note that some locative types such as ASDF:SYSTEMs and
    DECLARATIONs have no docstrings, and some Lisp
    implementations do not record all docstrings. The following are
    known to be missing:

    - COMPILER-MACRO docstrings on ABCL, AllegroCL, CCL, ECL;

    - METHOD-COMBINATION docstrings on ABCL, AllegroCL.

    Can be extended via DOCSTRING*.

- [function] SOURCE-LOCATION OBJECT &KEY ERROR

    Return the Swank source location for the defining form
    of OBJECT.

    The returned Swank location object is to be accessed only through
    the Source Locations API or to be passed to e.g Slime's
    slime-goto-source-location.

    If no source location was found,

    - if ERROR is NIL, then return NIL;

    - if ERROR is :ERROR, then return a list of the form (:ERROR
      <ERROR-MESSAGE>) suitable for slime-goto-source-location;

    - if ERROR is T, then signal an ERROR condition with the same error
      message as in the previous case.

    Note that the availability of source location information varies
    greatly across Lisp implementations.

    Can be extended via SOURCE-LOCATION*.

## Basic Locative Types

The following are the locative types supported out of the
box. As all locative types, they are named by symbols. When there is
a CL type corresponding to the reference's locative type, the
references can be RESOLVEd to a unique object as is the case in

    (resolve (dref 'print 'function))
    ==> #<FUNCTION PRINT>
    => T

Even if there is no such CL type, the ARGLIST, the DOCSTRING, and
the SOURCE-LOCATION of the defining form is usually recorded unless
otherwise noted.

The basic locative types and their inheritance structure is loosely
based on the DOC-TYPE argument of CL:DOCUMENTATION.

### Locatives for Variables

- [locative] VARIABLE &OPTIONAL INITFORM

    - Direct locative subtypes: GLOSSARY-TERM, SECTION, CONSTANT

    Refers to a global special variable.
    INITFORM, or if not specified, the global value of the variable is
    to be used for presentation.

        (dref '*print-length* 'variable)
        ==> #<DREF *PRINT-LENGTH* VARIABLE>

    VARIABLE references do not RESOLVE.

- [locative] CONSTANT &OPTIONAL INITFORM

    - Direct locative supertypes: VARIABLE

    Refers to a constant variable defined with DEFCONSTANT. INITFORM,
    or if not specified, the value of the constant is included in the
    documentation. The CONSTANT locative is like the VARIABLE locative,
    but it also checks that its object is CONSTANTP.

    CONSTANT references do not RESOLVE.

### Locatives for Macros

- [locative] SETF

    - Direct locative subtypes: SETF-METHOD, SETF-FUNCTION

    Refers to a setf expander (see DEFSETF and DEFINE-SETF-EXPANDER).

    Setf functions (e.g. (DEFUN (SETF NAME) ...) or the same
    with DEFGENERIC) are handled by the SETF-FUNCTION,
    SETF-GENERIC-FUNCTION, and SETF-METHOD locatives.

    SETF expander references do not RESOLVE.

- [locative] MACRO

    Refers to a global macro, typically defined with DEFMACRO, or to a
    special operator.

    MACRO references resolve to the MACRO-FUNCTION of their NAME or
    signal RESOLVE-ERROR if that's NIL.

- [locative] SYMBOL-MACRO

    Refers to a global symbol macro, defined with DEFINE-SYMBOL-MACRO.
    Note that since DEFINE-SYMBOL-MACRO does not support docstrings, PAX
    defines methods on the DOCUMENTATION generic function specialized on
    (DOC-TYPE (EQL 'SYMBOL-MACRO)).

        (define-symbol-macro my-mac 42)
        (setf (documentation 'my-mac 'symbol-macro)
              "This is MY-MAC.")
        (documentation 'my-mac 'symbol-macro)
        => "This is MY-MAC."

    SYMBOL-MACRO references do not RESOLVE.

- [locative] COMPILER-MACRO

    - Direct locative subtypes: SETF-COMPILER-MACRO

    Refers to a COMPILER-MACRO-FUNCTION, typically defined with
    DEFINE-COMPILER-MACRO.

- [locative] SETF-COMPILER-MACRO

    - Direct locative supertypes: COMPILER-MACRO

    Refers to a compiler macro with a setf function name.

    SETF-COMPILER-MACRO references do not RESOLVE.

### Locatives for Functions and Methods

- [locative] FUNCTION

    - Direct locative subtypes: STRUCTURE-ACCESSOR, SETF-FUNCTION, GENERIC-FUNCTION

    Refers to a global function, typically defined with DEFUN. The
    name must be a function name. It is also allowed to
    reference GENERIC-FUNCTIONs as FUNCTIONs:

        (dref 'docstring 'function)
        ==> #<DREF DOCSTRING FUNCTION>

- [locative] SETF-FUNCTION

    - Direct locative supertypes: FUNCTION, SETF

    - Direct locative subtypes: STRUCTURE-ACCESSOR, SETF-GENERIC-FUNCTION

    Refers to a global FUNCTION with a setf function name.

        (defun (setf ooh) ())
        (locate #'(setf ooh))
        ==> #<DREF OOH SETF-FUNCTION>
        (dref 'ooh 'setf-function)
        ==> #<DREF OOH SETF-FUNCTION>
        (dref '(setf ooh) 'function)
        ==> #<DREF OOH SETF-FUNCTION>

- [locative] GENERIC-FUNCTION

    - Direct locative supertypes: FUNCTION

    - Direct locative subtypes: SETF-GENERIC-FUNCTION

    Refers to a GENERIC-FUNCTION, typically defined with
    DEFGENERIC. The name must be a function name.

- [locative] SETF-GENERIC-FUNCTION

    - Direct locative supertypes: GENERIC-FUNCTION, SETF-FUNCTION

    Refers to a global GENERIC-FUNCTION with a setf function name.

        (defgeneric (setf oog) ())
        (locate #'(setf oog))
        ==> #<DREF OOG SETF-GENERIC-FUNCTION>
        (dref 'oog 'setf-function)
        ==> #<DREF OOG SETF-GENERIC-FUNCTION>
        (dref '(setf oog) 'function)
        ==> #<DREF OOG SETF-GENERIC-FUNCTION>

- [locative] METHOD &REST QUALIFIERS-AND-SPECIALIZERS

    - Direct locative subtypes: WRITER, READER, SETF-METHOD

    Refers to a METHOD. name must be a function name.
    METHOD-QUALIFIERS-AND-SPECIALIZERS has the form

        (<QUALIFIER>* <SPECIALIZERS>)

    For example, the method

        (defgeneric foo-gf (x y z)
          (:method :around (x (y (eql 'xxx)) (z string))
            (values x y z)))

    can be referred to as

        (dref 'foo-gf '(method :around (t (eql xxx) string)))
        ==> #<DREF FOO-GF (METHOD :AROUND (T (EQL XXX) STRING))>

    METHOD is not EXPORTABLE-LOCATIVE-TYPE-P.

- [locative] SETF-METHOD &REST METHOD-QUALIFIERS-AND-SPECIALIZERS

    - Direct locative supertypes: METHOD, SETF

    - Direct locative subtypes: ACCESSOR

    Refers to a METHOD of a SETF-GENERIC-FUNCTION.

        (defgeneric (setf oog) (v)
          (:method ((v string))))
        (locate (find-method #'(setf oog) () (list (find-class 'string))))
        ==> #<DREF OOG (SETF-METHOD (STRING))>
        (dref 'oog '(setf-method (string)))
        ==> #<DREF OOG (SETF-METHOD (STRING))>
        (dref '(setf oog) '(method (string)))
        ==> #<DREF OOG (SETF-METHOD (STRING))>

- [locative] METHOD-COMBINATION

    Refers to a METHOD-COMBINATION, defined with
    DEFINE-METHOD-COMBINATION.

    METHOD-COMBINATION references do not RESOLVE.

- [locative] READER CLASS-NAME

    - Direct locative supertypes: METHOD

    - Direct locative subtypes: ACCESSOR

    Refers to a :READER method in a DEFCLASS:

        (defclass foo ()
          ((xxx :reader foo-xxx)))
        
        (dref 'foo-xxx '(reader foo))
        ==> #<DREF FOO-XXX (READER FOO)>

- [locative] WRITER CLASS-NAME

    - Direct locative supertypes: METHOD

    - Direct locative subtypes: ACCESSOR

    Like ACCESSOR, but refers to a :WRITER method in a DEFCLASS.

- [locative] ACCESSOR CLASS-NAME

    - Direct locative supertypes: READER, WRITER, SETF-METHOD

    Refers to an :ACCESSOR in a DEFCLASS.

    An :ACCESSOR in DEFCLASS creates a reader and a writer method.
    Somewhat arbitrarily, ACCESSOR references RESOLVE to the writer
    method but can be LOCATEd with either.

- [locative] STRUCTURE-ACCESSOR &OPTIONAL STRUCTURE-CLASS-NAME

    - Direct locative supertypes: SETF-FUNCTION, FUNCTION

    Refers to an accessor function generated by DEFSTRUCT.
    A LOCATE-ERROR condition is signalled if the wrong
    STRUCTURE-CLASS-NAME is provided.

    Note that there is no portable way to detect structure accessors,
    and on some platforms, (LOCATE #'MY-ACCESSOR), DEFINITIONS and
    DREF-APROPOS will return FUNCTION references instead. On such
    platforms, STRUCTURE-ACCESSOR references do not RESOLVE.

### Locatives for Types and Declarations

- [locative] TYPE

    - Direct locative subtypes: CLASS

    This locative can refer to types and classes and
    conditions, simply put, to things defined by DEFTYPE,
    DEFCLASS and DEFINE-CONDITION.

        (deftype my-type () t)
        (dref 'my-type 'type)
        ==> #<DREF MY-TYPE TYPE>

        (dref 'xref 'type)
        ==> #<DREF XREF CLASS>

        (dref 'locate-error 'type)
        ==> #<DREF LOCATE-ERROR CONDITION>

    TYPE references do not RESOLVE.

- [locative] CLASS

    - Direct locative supertypes: TYPE

    - Direct locative subtypes: CONDITION, STRUCTURE

    Naturally, CLASS is the locative type for CLASSes.

    Also, see the related CONDITION locative.

- [locative] STRUCTURE

    - Direct locative supertypes: CLASS

    Refers to a STRUCTURE-CLASS, typically defined with DEFSTRUCT.

- [locative] DECLARATION

    Refers to a declaration, used in DECLARE, DECLAIM and PROCLAIM.

    User code may also define new declarations with CLTL2 functionality,
    but there is currently no way to provide a docstring, and their
    ARGLIST is always NIL.

        (cl-environments:define-declaration my-decl (&rest things)
          (values :declare (cons 'foo things)))

    DECLARATION references do not RESOLVE.

    Also, SOURCE-LOCATION on declarations currently only works on SBCL.

### Locatives for the Condition System

- [locative] CONDITION

    - Direct locative supertypes: CLASS

    Although CONDITION is not SUBTYPEP of CLASS, actual condition
    objects are commonly instances of a condition class that is a CLOS
    class. HyperSpec ISSUE:CLOS-CONDITIONS and
    ISSUE:CLOS-CONDITIONS-AGAIN provide the relevant history.

    Whenever a CLASS denotes a CONDITION, its DREF-LOCATIVE-TYPE will be
    CONDITION:

        (dref 'locate-error 'class)
        ==> #<DREF LOCATE-ERROR CONDITION>

- [locative] RESTART

    A locative to refer to the definition of a restart defined by
    DEFINE-RESTART.

- [macro] DEFINE-RESTART SYMBOL LAMBDA-LIST &BODY DOCSTRING

    Associate a definition with the name of a restart, which must be a symbol.
    LAMBDA-LIST should be what calls like (INVOKE-RESTART '<SYMBOL>
    ...) must conform to, but this not enforced.

    PAX "defines" standard CL restarts such as USE-VALUE with
    DEFINE-RESTART:

        (first-line (source-location-snippet
                     (source-location (dref 'use-value 'restart))))
        => "(define-restart use-value (value)"

    Note that while there is a CL:RESTART class, its instances have no
    docstring or source location.

### Locatives for Packages and Readtables

- [locative] ASDF/SYSTEM:SYSTEM

    Refers to an already loaded ASDF:SYSTEM (those in ASDF:REGISTERED-SYSTEMS).
    The name may be anything ASDF:FIND-SYSTEM supports.

    ASDF:SYSTEM is not EXPORTABLE-LOCATIVE-TYPE-P.

- [locative] PACKAGE

    Refers to a PACKAGE, defined by DEFPACKAGE or MAKE-PACKAGE.
    The name may be anything FIND-PACKAGE supports.

    PACKAGE is not EXPORTABLE-LOCATIVE-TYPE-P.

- [locative] READTABLE

    Refers to a named READTABLE defined with
    NAMED-READTABLES:DEFREADTABLE, which associates a global name and a
    docstring with the readtable object. The name may be anything
    FIND-READTABLE supports.

    READTABLE references RESOLVE to FIND-READTABLE on their name.

### Locatives for Unknown Definitions

- [locative] UNKNOWN DSPEC

    This locative type allows PAX to work in a limited way with
    definition types it doesn't know. UNKNOWN definitions come from
    DEFINITIONS, which uses SWANK/BACKEND:FIND-DEFINITIONS. The
    following examples show PAX stuffing the Swank
    dspec (:DEFINE-ALIEN-TYPE DOUBLE-FLOAT) into an UNKNOWN locative
    on SBCL.

        (definitions 'double-float)
        ==> (#<DREF DOUBLE-FLOAT CLASS>
        -->  #<DREF DOUBLE-FLOAT (UNKNOWN (:DEFINE-ALIEN-TYPE DOUBLE-FLOAT))>)

        (dref 'double-float '(unknown (:define-alien-type double-float)))
        ==> #<DREF DOUBLE-FLOAT (UNKNOWN (:DEFINE-ALIEN-TYPE DOUBLE-FLOAT))>

    ARGLIST and DOCSTRING return NIL for UNKNOWNs, but SOURCE-LOCATION
    works.

### Locatives for DRef Constructs

- [locative] DTYPE

    - Direct locative subtypes: LOCATIVE

    Locative for DTYPEs defined with DEFINE-DTYPE and LOCATIVE types.
    DTYPE is to LOCATIVE as TYPE is to CLASS.

    The TOP of the DTYPE hierarchy:

        (dref 'top 'dtype)
        ==> #<DREF TOP DTYPE>

    This very definition:

        (dref 'dtype 'locative)
        ==> #<DREF DTYPE LOCATIVE>

- [locative] LOCATIVE

    - Direct locative supertypes: DTYPE

    This is the locative for locative types defined with
    DEFINE-LOCATIVE-TYPE, DEFINE-PSEUDO-LOCATIVE-TYPE and
    DEFINE-LOCATIVE-ALIAS.

        (first-line (source-location-snippet
                     (source-location (dref 'macro 'locative))))
        => "(define-locative-type macro ()"

- [locative] LAMBDA &KEY ARGLIST ARGLIST-TYPE DOCSTRING DOCSTRING-PACKAGE FILE FILE-POSITION SNIPPET &ALLOW-OTHER-KEYS

    A pseudo locative type that carries its
    ARGLIST, DOCSTRING and SOURCE-LOCATION in the locative itself. See
    MAKE-SOURCE-LOCATION for the description of FILE, FILE-POSITION, and
    SNIPPET. LAMBDA references do not RESOLVE. The name must be NIL.

        (arglist (dref nil '(lambda :arglist ((x y) z)
                                    :arglist-type :macro)))
        => ((X Y) Z)
        => :MACRO

        (docstring (dref nil '(lambda :docstring "xxx"
                                      :docstring-package :dref)))
        => "xxx"
        ==> #<PACKAGE "DREF">

        (source-location-file
         (source-location (dref nil '(lambda :file "xxx.el"))))
        => "xxx.el"

    Also, see the PAX:INCLUDE locative.

## Extending DRef

### Extension Tutorial

Let's see how to tell DRef about new kinds of definitions through
the example of the implementation of the CLASS locative. Note that
this is a verbatim PAX:INCLUDE of the sources. Please
ignore any internal machinery. The first step is to define the
locative type:

    (define-locative-type class (type)
      "Naturally, CLASS is the locative type for [CLASS][class]es.
    
      Also, see the related CONDITION locative.")

Then, we make it possible to look up CLASS definitions:

    (define-locator class ((class class))
      (make-instance 'class-dref :name (class-name class) :locative 'class))
    
    (define-lookup class (symbol locative-args)
      (unless (and (symbolp symbol)
                   (find-class symbol nil))
        (locate-error "~S does not name a class." symbol))
      (make-instance 'class-dref :name symbol :locative 'class))

DEFINE-LOCATOR makes (LOCATE (FIND-CLASS 'DREF)) work, while
DEFINE-LOOKUP is for (DREF 'DREF 'CLASS). Naturally, for locative
types that do not define first-class objects, the first method
cannot be defined.

Finally, we define a RESOLVE* method to recover the CLASS
object from a CLASS-DREF. We also specialize DOCSTRING* and
SOURCE-LOCATION*:

    (defmethod resolve* ((dref class-dref))
      (find-class (dref-name dref)))
    
    (defmethod docstring* ((class class))
      (documentation* class t))
    
    (defmethod source-location* ((dref class-dref))
      (swank-source-location* (resolve dref) (dref-name dref) 'class))

We took advantage of having just made the class locative type being
RESOLVEable, by specializing DOCSTRING* on the CLASS class.
SOURCE-LOCATION* was specialized on CLASS-DREF to demonstrate how
this can be done for non-RESOLVEable locative types.

Classes have no arglist, so no ARGLIST* method is needed. In the
following, we describe the pieces in detail.

### Locative Type Hierarchy

Locative types form their own hierarchy, that
is only superficially similar to the Lisp CLASS hierarchy.
The hierarchies of LISP-LOCATIVE-TYPES and PSEUDO-LOCATIVE-TYPES
are distinct. That is, the DREF-CLASS of a Lisp locative type must
not be a subclass of a PSEUDO one, and vice versa. This is enforced
by DEFINE-LOCATIVE-TYPE and DEFINE-PSEUDO-LOCATIVE-TYPE.

- [function] DREF-CLASS LOCATIVE-TYPE

    Return the name of the CLASS used to represent definitions with
    LOCATIVE-TYPE. This is always a subclass of DREF. Returns
    NIL if LOCATIVE-TYPE is not a valid locative type.

    Note that the actual TYPE-OF a DREF is mostly intended for
    Extending DRef. Hence, it is hidden when a DREF is printed:

        (dref 'print 'function)
        ==> #<DREF PRINT FUNCTION>
        (type-of *)
        => FUNCTION-DREF

    Due to Canonicalization, the actual type may be a proper subtype of
    DREF-CLASS:

        (dref 'documentation 'function)
        ==> #<DREF DOCUMENTATION GENERIC-FUNCTION>
        (type-of *)
        => GENERIC-FUNCTION-DREF
        (subtypep 'generic-function-dref 'function-dref)
        => T
        => T

- [function] LOCATIVE-TYPE-DIRECT-SUPERS LOCATIVE-TYPE

    List the locative types whose DREF-CLASSes are direct superclasses
    of the DREF-CLASS of LOCATIVE-TYPE. These can be considered
    supertypes of LOCATIVE-TYPE in the sense of DTYPEP.

    This is ordered as in the corresponding definition.

- [function] LOCATIVE-TYPE-DIRECT-SUBS LOCATIVE-TYPE

    List the locative types whose DREF-CLASSes are direct subclasses
    of the DREF-CLASS of LOCATIVE-TYPE. These can be considered subtypes
    of LOCATIVE-TYPE in the sense of DTYPEP.

    This list is in reverse definition order.

### Defining Locative Types

- [macro] DEFINE-LOCATIVE-TYPE LOCATIVE-TYPE-AND-LAMBDA-LIST LOCATIVE-SUPERTYPES &OPTIONAL DOCSTRING DREF-DEFCLASS-FORM

    Declare LOCATIVE-TYPE as a LOCATIVE,
    which is the first step in Extending DRef.

    - Simple example

        To define a locative type called DUMMY that takes no arguments
        and is not a locative subtype of any other locative type:

            (define-locative-type dummy ()
              "Dummy docstring.")

        With this definition, only the locatives DUMMY and its
        equivalent form (DUMMY) are valid. The above defines a DREF
        subclass called DUMMY-DREF in the current package. All
        definitions with locative type DUMMY and its locatives
        subtypes must be instances of DUMMY-DREF.

        (LOCATE 'DUMMY 'LOCATIVE) refers to this definition. That is,
        ARGLIST, DOCSTRING and SOURCE-LOCATION all work on
        it.

    - Complex example

        DUMMY may have arguments X and Y and inherit from locative
        types L1 and L2:

            (define-locative-type (dummy x &key y) (l1 l2)
              "Dummy docstring."
              (defclass dummy-dref ()
                ((xxx :initform nil :accessor dummy-xxx))))

        One may change name of DUMMY-DREF, specify superclasses and
        add slots as with DEFCLASS. Behind the scenes, the DREF classes
        of L1 and L2 are added automatically to the list of
        superclasses.

    Arguments:

    - The general form of LOCATIVE-TYPE-AND-LAMBDA-LIST
      is (LOCATIVE-TYPE &REST LAMBDA-LIST), where LOCATIVE-TYPE is a
      SYMBOL, and LAMBDA-LIST is a destructuring lambda list.
      The LOCATIVE-ARGS of DREFs with locative type
      LOCATIVE-TYPE (the argument given to this macro) always conform to
      this lambda list. See CHECK-LOCATIVE-ARGS.

        If LOCATIVE-TYPE-AND-LAMBDA-LIST is a single symbol, then that's
        interpreted as LOCATIVE-TYPE, and LAMBDA-LIST is NIL.

    - LOCATIVE-SUPERTYPES is a list of locative types whose
      DREF-CLASSes are added to prepended to the list of superclasses
      this definition.

    Locative types defined with DEFINE-LOCATIVE-TYPE can be listed with
    LISP-LOCATIVE-TYPES.

- [macro] DEFINE-PSEUDO-LOCATIVE-TYPE LOCATIVE-TYPE-AND-LAMBDA-LIST LOCATIVE-SUPERTYPES &OPTIONAL DOCSTRING DREF-DEFCLASS-FORM

    Like DEFINE-LOCATIVE-TYPE, but declare that
    LOCATIVE-TYPE does not correspond to definitions in the
    running Lisp. Definitions with pseudo locatives are of DTYPE PSEUDO
    and are not listed by default by DEFINITIONS.

    Locative types defined with DEFINE-PSEUDO-LOCATIVE-TYPE can be
    listed with PSEUDO-LOCATIVE-TYPES.

- [macro] DEFINE-LOCATIVE-ALIAS ALIAS LOCATIVE-TYPE &BODY DOCSTRING

    Define ALIAS that can be substituted for LOCATIVE-TYPE (both
    SYMBOLs) for the purposes of LOCATEing. LOCATIVE-TYPE must
    exist (i.e. be among LOCATIVE-TYPES). For example, let's define
    OBJECT as an alias of the CLASS locative:

        (define-locative-alias object class)

    Then, LOCATEing with OBJECT will find the CLASS:

        (dref 'xref 'object)
        ==> #<DREF XREF CLASS>

    The LOCATIVE-ARGS of OBJECT (none in the above) are passed on to
    CLASS.

        (arglist (dref 'object 'locative))
        => (&REST ARGS)
        => :DESTRUCTURING

    Note that LOCATIVE-ALIASES are not LOCATIVE-TYPES and are not valid
    DTYPEs.

    Also, see Locative Aliases in PAX.

#### Symbol Locatives

Let's see how the opaque DEFINE-SYMBOL-LOCATIVE-TYPE and the
obscure DEFINE-DEFINER-FOR-SYMBOL-LOCATIVE-TYPE macros work together
to simplify the common task of associating definition with a symbol
in a certain context.

- [macro] DEFINE-SYMBOL-LOCATIVE-TYPE LOCATIVE-TYPE-AND-LAMBDA-LIST LOCATIVE-SUPERTYPES &OPTIONAL DOCSTRING DREF-CLASS-DEF

    Similar to DEFINE-LOCATIVE-TYPE, but it assumes that all things
    LOCATEable with LOCATIVE-TYPE are going to be symbols defined with a
    definer defined with DEFINE-DEFINER-FOR-SYMBOL-LOCATIVE-TYPE. Symbol
    locatives are for attaching a definition (along with arglist,
    documentation and source location) to a symbol in a particular
    context. An example will make everything clear:

        (define-symbol-locative-type direction ()
          "A direction is a symbol.")
        
        (define-definer-for-symbol-locative-type define-direction direction
          "With DEFINE-DIRECTION, one can document what a symbol means when
          interpreted as a DIRECTION.")
        
        (define-direction up ()
          "UP is equivalent to a coordinate delta of (0, -1).")

    After all this, (DREF 'UP 'DIRECTION) refers to the
    DEFINE-DIRECTION form above.

    The DREF-CLASS of the defined locative type inherits from
    SYMBOL-LOCATIVE-DREF, which may be used for specializing when
    implementing new operations.

- [macro] DEFINE-DEFINER-FOR-SYMBOL-LOCATIVE-TYPE NAME LOCATIVE-TYPE &BODY DOCSTRING

    Define a macro with NAME that can be used to attach a lambda list,
    documentation, and source location to a symbol in the context of
    LOCATIVE-TYPE. The defined macro's arglist is (SYMBOL LAMBDA-LIST
    &OPTIONAL DOCSTRING). LOCATIVE-TYPE is assumed to have been defined
    with DEFINE-SYMBOL-LOCATIVE-TYPE.

### Extending LOCATE

Internally, LOCATE finds an initial DREF of its OBJECT
argument with a lookup or with a
locator. This initial DREF is then canonicalized
with a series of casts. In more detail, the process
is as follows.

- If the OBJECT argument of LOCATE is a DREF, then it is returned
  without processing.

Else, LOCATE first needs to finds the initial definition.

#### Initial Definition

LOCATE can find the initial definition in one of two ways:

- With direct
lookup

    If OBJECT is an XREF, then the lookup
    for (XREF-LOCATIVE-TYPE OBJECT) is invoked. For an XREF with the
    locative (METHOD (NUMBER)), this would be the lookup
    defined as

        (define-lookup method (name locative-args) ...)

- With locator
search

    Else, OBJECT is a normal Lisp object, such as a METHOD
    object from FIND-METHOD. The first of LISP-LOCATIVE-TYPES whose
    locator succeeds provides the initial
    definition, which may be defined like this:

        (define-locator method ((obj method)) ...)

    This is a locator that returns definitions with the METHOD
    locative type and takes an argument named OBJ of class
    METHOD (which is like a specializer in DEFMETHOD).

    - LISP-LOCATIVE-TYPES are tried one by one in the order
      specified there.

    - For a given locative type, if there are multiple locators,
      standard CLOS method selection applies.

#### Canonicalization

The initial definition thus found is then canonicalized so that
there is a unique definition under XREF=:

    (locate #'arglist*)
    ==> #<DREF ARGLIST* GENERIC-FUNCTION>
    (dref 'arglist* 'function)
    ==> #<DREF ARGLIST* GENERIC-FUNCTION>
    (dref 'arglist* 'generic-function)
    ==> #<DREF ARGLIST* GENERIC-FUNCTION>

Canonicalization is performed by recursively attempting to
downcast the current definition to one of its
LOCATIVE-TYPE-DIRECT-SUBS in a depth-first manner, backtracking if a
cast fails.

##### Default Downcast

Downcasting to direct locative subtypes is performed by default by looking up
the definition where the locative type is replaced with its sub
while the name and the locative args remain the same.

##### Cast Name Change

Casts must be careful about changing DREF-NAME.

Their DREF argument and the DREF returned must have the
same DREF-NAME (under EQUAL, see XREF=) or it must be possible to
upcast the returned value to the DREF argument's DREF-LOCATIVE-TYPE.

- Implementation note

    The purpose of this rule is to allow DTYPEP answer this correctly:

        (defclass foo ()
          ((a :accessor foo-a)))
        (dref '(setf foo-a) '(method (t foo)))
        ==> #<DREF FOO-A (ACCESSOR FOO)>
        (dtypep * '(method (t foo)))
        => T
        ;; Internally, DTYPEP upcast #<DREF FOO-A (ACCESSOR FOO)>
        ;; and checks that the locative args of the resulting
        ;; definition match those in (METHOD (T FOO)).
        (locate* ** 'method)
        ==> #<DREF (SETF FOO-A) (METHOD (T FOO))>

    For even more background, also note that if the name remains the
    same but locative args change, then DTYPEP can simply check with
    DREF if there is a definition of the name with the
    given locative:

        (defclass foo ()
          ((r :reader foo-r)))
        (dref 'foo-r '(reader foo))
        ==> #<DREF FOO-R (READER FOO)>
        (dtypep * '(method (foo)))
        => T
        ;; Behind the scenes, DTYPEP does this:
        (xref= ** (dref 'foo-r '(method (foo))))
        => T

#### Defining Lookups, Locators and Casts

As we have seen, the Initial Definition is provided either by a
lookup or a locator, then Canonicalization works with
casts. Here, we look at how to define these.

Implementation note: All three are currently implemented as
methods of generic functions with EQL specializers for
the locative type, which may easily prove to be problematic down the
road. To make future changes easier, the generic function and the
methods are hidden behind e.g. the DEFINE-LOOKUP and CALL-LOOKUP
macros.

- [variable] *CHECK-LOCATE* NIL

    Enable runtime verification of invariants during LOCATE calls.
    This carries a performance penalty and is intended for testing and
    debugging.

    In particular, enforce the rule of Cast Name Change and that lookups, locators and
    casts obey the following:

    - The value returned must be either NIL or a DREF. Alternatively,
      LOCATE-ERROR may be signalled.

    - If a DREF is returned, then its DREF-LOCATIVE-TYPE must be
      LOCATIVE-TYPE, and its class must be the DREF-CLASS of
      LOCATIVE-TYPE.

    - LOCATIVE-ARGS must be congruent with the destructuring lambda list
      in the definition of LOCATIVE-TYPE.

- [macro] DEFINE-LOOKUP LOCATIVE-TYPE (NAME LOCATIVE-ARGS) &BODY BODY

    Define a method of looking up definitions of LOCATIVE-TYPE
    with the given LOCATIVE-ARGS. Lookups are invoked by LOCATE when its
    OBJECT argument is an XREF with LOCATIVE-TYPE but it is not a DREF,
    as in the case of (DREF 'PRINT 'FUNCTION). When called, the
    variables NAME and LOCATIVE-ARGS are bound to XREF-NAME and
    XREF-LOCATIVE-ARGS of the XREF. LOCATIVE-ARGS is validated with
    CHECK-LOCATIVE-ARGS before BODY is evaluated.

        (define-lookup variable (name locative-args)
          (unless (special-variable-name-p name)
            (locate-error))
          (make-instance 'variable-dref :name name :locative 'variable))

    - LOCATIVE-TYPE is a valid locative type.

    - NAME and LOCATIVE-ARGS are both SYMBOLs.

    The above are enforced at macro-expansion time.

    - BODY must follow the rules in *CHECK-LOCATE*.

- [macro] CALL-LOOKUP NAME LOCATIVE-TYPE LOCATIVE-ARGS

    Call the lookup for LOCATIVE-TYPE with NAME
    and LOCATIVE-ARGS.

- [macro] DEFINE-LOCATOR LOCATIVE-TYPE ((OBJECT CLASS)) &BODY BODY

    Define a method of finding the definition with LOCATIVE-TYPE of
    instances of CLASS. When a locator's BODY is evaluated, OBJECT is
    bound to such an instance.

        (define-locator class ((class class))
          (make-instance 'class-dref :name (class-name class) :locative 'class))

    - LOCATIVE-TYPE is one of LISP-LOCATIVE-TYPES. This is because
      PSEUDO-LOCATIVE-TYPES never RESOLVE to first-class objects.

    - OBJECT is a SYMBOL.

    - CLASS names a CLASS that is not a subtype of
      XREF. For how to convert definitions from one locative
      type to another, see DEFINE-CAST.

    The above are enforced at macro-expansion time.

    - BODY must follow the rules in *CHECK-LOCATE*.

    In contrast to when the Initial Definition is created from an
    XREF (see DEFINE-LOOKUP), here LOCATIVE-ARGS are determined from
    OBJECT.

- [macro] CALL-LOCATOR OBJECT LOCATIVE-TYPE

    Call the locator for LOCATIVE-TYPE with OBJECT.

- [macro] DEFINE-CAST LOCATIVE-TYPE ((DREF DREF-CLASS)) &BODY BODY

    Define a method of converting a definition to another
    with LOCATIVE-TYPE. When a cast's BODY is evaluated, DREF is bound
    to an instance DREF-CLASS, which denotes a valid but potentially
    non-canonical definition.

    Note the Default Downcast often suffices, and defining a cast is
    only necessary if the name or the locative
    args change:

        (define-cast accessor ((dref reader-dref))
          (let ((name (dref-name dref))
                (class (second (dref-locative dref))))
            (when (ignore-errors (find-accessor-slot-definition name class))
              (make-instance 'accessor-dref :name name
                              :locative `(accessor ,class)))))

    - LOCATIVE-TYPE is a valid locative type.

    - If LOCATIVE-TYPE is one of PSEUDO-LOCATIVE-TYPES, then DREF-CLASS
      must be of another pseudo locative type.

    - DREF-CLASS is either a direct downcast or an potentially
      non-direct upcast.

        - Downcast: In this case, LOCATIVE-TYPE is one of
          LOCATIVE-TYPE-DIRECT-SUBS of (DREF-CLASS-TO-LOCATIVE-TYPE
          DREF-CLASS).

            Downcasting to non-direct subtypes is done in multiple
            steps. Consequently,the BODY of a downcast can rely on
            (CLASS-OF DREF) being CLASS, not any subclass thereof.

        - Upcast: LOCATIVE-TYPE is different but reachable
          from (DREF-CLASS-TO-LOCATIVE-TYPE DREF-CLASS) by repeatedly
          choosing one of LOCATIVE-TYPE-DIRECT-SUPERS. Upcasting to
          non-direct supertypes is done in one step.

    The above are enforced at macro-expansion time.

    - BODY must follow the rules in *CHECK-LOCATE*, including those in
      Cast Name Change.

- [macro] CALL-CAST LOCATIVE-TYPE DREF

    Call the cast to LOCATIVE-TYPE with DREF.

- [function] LOCATE-ERROR &OPTIONAL FORMAT-CONTROL &REST FORMAT-ARGS

    Call this function to signal a LOCATE-ERROR condition from the
    dynamic extent of a LOCATE call, that is, from the BODYs
    of DEFINE-LOOKUP, DEFINE-LOCATOR and DEFINE-CAST. It is an error to
    call LOCATE-ERROR elsewhere.

    FORMAT-CONTROL, if non-NIL, is a format control for which
    FORMAT-ARGS are suitable.

- [macro] CHECK-LOCATIVE-ARGS LOCATIVE-TYPE LOCATIVE-ARGS

    Signal a LOCATE-ERROR condition if LOCATIVE-ARGS do not match the
    LAMBDA-LIST argument of LOCATIVE-TYPE (not evaluated).

### Extending Everything Else

- [generic-function] RESOLVE* DREF

    Return the object defined by the definition DREF
    refers to. Signal a RESOLVE-ERROR condition by calling the
    RESOLVE-ERROR function if the lookup fails.

    To keep RESOLVE a partial inverse of LOCATE, DEFINE-LOCATOR may be
    necessary for RESOLVEable definitions. This function is for
    extending RESOLVE. Do not call it directly.

    It is an error for methods of this generic function to return an
    XREF.

- [function] RESOLVE-ERROR &REST FORMAT-AND-ARGS

    Call this function to signal a RESOLVE-ERROR condition from the
    dynamic extent of a RESOLVE* method. It is an error to call
    RESOLVE-ERROR elsewhere.

    FORMAT-AND-ARGS, if non-NIL, is a format string and arguments
    suitable for FORMAT.

- [generic-function] MAP-DEFINITIONS-OF-NAME FN NAME LOCATIVE-TYPE

    Call FN with DREFs which can be LOCATEd
    with an XREF with NAME, LOCATIVE-TYPE and some LOCATIVE-ARGS. The
    strange wording here is because there may be multiple ways (and thus
    XREFs) that refer to the same definition.

    For most locative types, there is at most one such definition, but
    for METHOD, for example, there may be many. The default method
    simply does (DREF NAME LOCATIVE-TYPE NIL) and calls FN with result
    if DREF succeeds.

    FN must not be called with the same (under XREF=) definition
    multiple times.

    This function is for extending DEFINITIONS and DREF-APROPOS. Do not
    call it directly.

- [generic-function] MAP-DEFINITIONS-OF-TYPE FN LOCATIVE-TYPE

    Call FN with DREFs which can be LOCATEd
    with an XREF with LOCATIVE-TYPE with some NAME and LOCATIVE-ARGS.

    The default method forms XREFs by combining each interned symbol as
    names with LOCATIVE-TYPE and no LOCATIVE-ARGS and calls FN if it
    LOCATEs a definition.

    FN may be called with DREFs that are XREF= but differ in the XREF in
    their DREF-ORIGIN.

    This function is for extending DREF-APROPOS. Do not call it
    directly.

- [generic-function] ARGLIST* OBJECT

    To extend ARGLIST, specialize OBJECT on a normal
    Lisp type or on a subclass of DREF.

    ARGLIST first calls ARGLIST* with its OBJECT argument. If that
    doesn't work (i.e. the second value returned is NIL), then it calls
    ARGLIST* with OBJECT either RESOLVEd (if it's a DREF) or LOCATEd (if
    it's not a DREF).

    - The default method returns NIL, NIL.

    - There is also a method specialized on DREFs, that looks
      up the DEFINITION-PROPERTY called ARGLIST and returns its value
      with VALUES-LIST. Thus, an arglist and its kind can be specified
      with something like

            (setf (definition-property xref 'arglist)
                  (list arglist :destructuring))

    This function is for extension only. Do not call it directly.

- [generic-function] DOCSTRING* OBJECT

    To extend DOCSTRING, specialize OBJECT on a normal
    Lisp type or on a subclass of DREF.

    DOCSTRING first calls DOCSTRING* with its OBJECT argument. If that
    doesn't work (i.e. NIL is returned), then it calls DOCSTRING* with
    OBJECT either RESOLVEd (if it's a DREF) or LOCATEd (if it's not a
    DREF).

    - The default method returns NIL.

    - There is also a method specialized on DREFs, that looks
      up the DEFINITION-PROPERTY called DOCSTRING and returns its value
      with VALUES-LIST. Thus, a docstring and a package can be specified
      with something like

            (setf (definition-property xref 'docstring)
                  (list docstring *package*))

    This function is for extension only. Do not call it directly.

- [generic-function] SOURCE-LOCATION* OBJECT

    To extend SOURCE-LOCATION, specialize OBJECT on a
    normal Lisp type or on a subclass of DREF.

    SOURCE-LOCATION first calls SOURCE-LOCATION* with its OBJECT
    argument. If that doesn't work (i.e. NIL or (:ERROR <MESSAGE>) is
    returned), then it calls SOURCE-LOCATION* with OBJECT either
    RESOLVEd (if it's a DREF) or LOCATEd (if it's not a DREF).

    SOURCE-LOCATION returns the last of the (:ERROR <MESSAGE>)s
    encountered or a generic error message if only NILs were returned.

    - The default method returns NIL.

    - There is also a method specialized on DREFs, that looks
      up the DEFINITION-PROPERTY called SOURCE-LOCATION. If present, it
      must be a function of no arguments that returns a source location
      or NIL. Typically, this is set up in the defining macro like this:

            (setf (definition-property xref 'source-location)
                  (this-source-location))

    This function is for extension only. Do not call it directly.

#### Definition Properties

Arbitrary data may be associated with definitions.
This mechanism is used by ARGLIST*, DOCSTRING* and
SOURCE-LOCATION* for easy extension.

The following functions take an XREF argument and not a DREF to
allow working with non-canonical or
non-existent definitions.

- [function] DEFINITION-PROPERTY XREF INDICATOR

    Return the value of the property associated with XREF whose name
    is EQL to INDICATOR. The second return value indicates whether the
    property was found. SETFable.

- [function] DELETE-DEFINITION-PROPERTY XREF INDICATOR

    Delete the property associated with XREF whose name is EQL to INDICATOR.
    Return true if the property was found.

- [function] DEFINITION-PROPERTIES XREF

    Return the properties of XREF as an association list.

- [function] DELETE-DEFINITION-PROPERTIES XREF

    Delete all properties associated with XREF.

- [function] MOVE-DEFINITION-PROPERTIES FROM-XREF TO-XREF

    Associate all properties of FROM-XREF with TO-XREF, as if readding
    them one-by-one with (SETF DEFINITION-PROPERTY), and
    deleting them from FROM-XREF with DELETE-DEFINITION-PROPERTY.

### DREF-CLASSes

These are the DREF-CLASSes corresponding to Basic Locative Types.
They are exported to make it possible to go beyond the
Basic Operations (e.g. PAX:DOCUMENT-OBJECT*). For
Defining Locative Types, they are not necessary, as
DEFINE-LOCATIVE-TYPE handles inheritance automatically based on its
LOCATIVE-SUPERTYPES argument.

for Variables

- [class] VARIABLE-DREF DREF

    DREF-EXT:DREF-CLASS of VARIABLE.

- [class] CONSTANT-DREF VARIABLE-DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:CONSTANT.

for Macros

- [class] MACRO-DREF DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:MACRO.

- [class] SYMBOL-MACRO-DREF DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:SYMBOL-MACRO.

- [class] COMPILER-MACRO-DREF DREF

    DREF-EXT:DREF-CLASS of COMPILER-MACRO.

- [class] SETF-DREF DREF

    DREF-EXT:DREF-CLASS of SETF.

- [class] SETF-COMPILER-MACRO-DREF COMPILER-MACRO-DREF

    DREF-EXT:DREF-CLASS of DREF:SETF-COMPILER-MACRO.

for Functions

- [class] FUNCTION-DREF DREF

    DREF-EXT:DREF-CLASS of FUNCTION.

- [class] SETF-FUNCTION-DREF FUNCTION-DREF SETF-DREF

    DREF-EXT:DREF-CLASS of DREF:SETF-FUNCTION.

- [class] GENERIC-FUNCTION-DREF FUNCTION-DREF

    DREF-EXT:DREF-CLASS of GENERIC-FUNCTION.

- [class] SETF-GENERIC-FUNCTION-DREF GENERIC-FUNCTION-DREF SETF-FUNCTION-DREF

    DREF-EXT:DREF-CLASS of DREF:SETF-GENERIC-FUNCTION.

- [class] METHOD-DREF DREF

    DREF-EXT:DREF-CLASS of METHOD.

- [class] SETF-METHOD-DREF METHOD-DREF SETF-DREF

    DREF-EXT:DREF-CLASS of DREF:SETF-METHOD.

- [class] METHOD-COMBINATION-DREF DREF

    DREF-EXT:DREF-CLASS of METHOD-COMBINATION.

- [class] READER-DREF METHOD-DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:READER.

- [class] WRITER-DREF METHOD-DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:WRITER.

- [class] ACCESSOR-DREF READER-DREF WRITER-DREF SETF-METHOD-DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:ACCESSOR.

- [class] STRUCTURE-ACCESSOR-DREF SETF-FUNCTION-DREF FUNCTION-DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:STRUCTURE-ACCESSOR.

for Types and Declarations

- [class] TYPE-DREF DREF

    DREF-EXT:DREF-CLASS of TYPE.

- [class] CLASS-DREF TYPE-DREF

    DREF-EXT:DREF-CLASS of CLASS.

- [class] DECLARATION-DREF DREF

    DREF-EXT:DREF-CLASS of DECLARATION.

for the Condition System

- [class] CONDITION-DREF CLASS-DREF

    DREF-EXT:DREF-CLASS of CONDITION.

- [class] RESTART-DREF SYMBOL-LOCATIVE-DREF

    DREF-EXT:DREF-CLASS of RESTART.

for Packages and Readtables

- [class] ASDF-SYSTEM-DREF DREF

    DREF-EXT:DREF-CLASS of ASDF/SYSTEM:SYSTEM.

- [class] PACKAGE-DREF DREF

    DREF-EXT:DREF-CLASS of PACKAGE.

- [class] READTABLE-DREF DREF

    DREF-EXT:DREF-CLASS of READTABLE.

for Unknown Definitions

- [class] UNKNOWN-DREF DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:UNKNOWN.

for DRef Constructs

- [class] DTYPE-DREF DREF

    DREF-EXT:DREF-CLASS of DREF:DTYPE.

- [class] LOCATIVE-DREF DTYPE-DREF

    DREF-EXT:DREF-CLASS of MGL-PAX:LOCATIVE.

- [class] SYMBOL-LOCATIVE-DREF DREF

    All locative types defined with
    DEFINE-SYMBOL-LOCATIVE-TYPE inherit from this class.

- [class] LAMBDA-DREF DREF

    DREF-EXT:DREF-CLASS of LAMBDA.

### Source Locations

These represent the file or buffer position of a defining
form and are returned by the SOURCE-LOCATION function. For
the details, see the Elisp function slime-goto-source-location.

- [function] MAKE-SOURCE-LOCATION &KEY FILE FILE-POSITION BUFFER BUFFER-POSITION SNIPPET

    Make a Swank source location. The ultimate reference is slime.el.
    When SNIPPET is provided, the match nearest to FILE-POSITION is
    determined (see the Elisp slime-isearch and
    SOURCE-LOCATION-ADJUSTED-FILE-POSITION).

- [function] SOURCE-LOCATION-P OBJECT

    See if OBJECT is a source location object.

- [function] SOURCE-LOCATION-FILE LOCATION

    Return the name of the file of the defining form.
    This may be NIL, for example, if LOCATION is of a defining
    form that was entered at the REPL, or compiled in the
    *slime-scratch* buffer.

- [function] SOURCE-LOCATION-FILE-POSITION LOCATION

    Return the file position of the defining form or NIL
    if it's not available. The first position is 0.

- [function] SOURCE-LOCATION-BUFFER LOCATION

    Return the name of the Emacs buffer of the defining form or
    NIL if there is no such Emacs buffer.

- [function] SOURCE-LOCATION-BUFFER-POSITION LOCATION

    Return the position of the defining form in
    SOURCE-LOCATION-BUFFER or NIL if it's not available. The first
    position is 1.

- [function] SOURCE-LOCATION-SNIPPET LOCATION

    Return the defining form or a prefix of it as a string or NIL
    if it's not available.

- [function] SOURCE-LOCATION-ADJUSTED-FILE-POSITION LOCATION

    Return the actual file position LOCATION points to allowing for 
    some deviation from the raw SOURCE-LOCATION-FILE-POSITION, which is
    adjusted by searching for the nearest occurrence of
    SOURCE-LOCATION-SNIPPET in the file. Needless to say, this can be a
    very expensive operation.

    If SOURCE-LOCATION-FILE is NIL, NIL is returned. If there is no
    snippet, or it doesn't match, then SOURCE-LOCATION-FILE-POSITION (or
    0 if that's NIL) is returned.

    This is a non-interactive companion to the Elisp function
    slime-location-offset, supporting only file positions and
    non-partial matching of snippets.

- [macro] THIS-SOURCE-LOCATION

    The value of this macro form is a function of no arguments that
    returns its own SOURCE-LOCATION.

* * *
###### \[generated by [MGL-PAX](https://github.com/melisgl/mgl-pax)\]
