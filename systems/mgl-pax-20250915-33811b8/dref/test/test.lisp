(in-package :dref-test)

(deftest test-util ()
  (test-has-setf-p))

(deftest test-has-setf-p ()
  (is (null (dref::has-setf-p 'undefined)))
  (is (dref::has-setf-p 'documentation))
  (is (dref::has-setf-p 'short-setf-with-fn))
  (is (dref::has-setf-p 'setf-fn))
  (is (dref::has-setf-p 'setf-gf))
  (is (null (dref::has-setf-p 'defun)))
  (with-failure-expected (*failure-on-long-setf*)
    (is (dref::has-setf-p 'long-setf))))


(deftest test-definitions ()
  (check-ref-sets (definitions 'undefined) ())
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp))
                               'failure))
    (check-ref-sets (definitions '*some-var*)
                    `(,(xref '*some-var* 'variable))))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp))
                               'failure))
    (check-ref-sets (definitions 'my-smac)
                    `(,(xref 'my-smac 'symbol-macro))))
  (check-ref-sets (definitions 'foo2) (list (xref 'foo2 'function)))
  (with-failure-expected ((alexandria:featurep :clisp))
    (check-ref-sets (definitions 'foo) (list (xref 'foo 'function)
                                             (xref 'foo 'class)
                                             (xref 'foo 'compiler-macro)))
    (check-ref-sets (definitions 'dref) (list (dref 'dref 'function)
                                              (dref 'dref 'package)
                                              (xref "dref" 'asdf:system)
                                              (xref 'dref 'class)))
    (check-ref-sets (definitions '(setf setf-fn))
                    (list (xref 'setf-fn 'setf-function)
                          (xref 'setf-fn 'setf-compiler-macro))))
  (with-failure-expected ((alexandria:featurep :abcl))
    (check-ref-sets (definitions "dref")
                    (if (string= (package-name 'dref) "dref")
                        (list (xref "dref" 'package)
                              (xref "dref" 'asdf:system))
                        (list (xref "dref" 'asdf:system))))
    (check-ref-sets (definitions "DREF" :dtype t)
                    (if (string= (package-name 'dref) "DREF")
                        (list (xref "DREF" 'package)
                              (xref "dref" 'asdf:system))
                        (list (xref "dref" 'asdf:system)))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (check-ref-sets (definitions 'bar)
                    `(,(xref 'bar 'macro)
                      ,(xref 'bar 'constant)
                      ,(xref 'bar 'type))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (check-ref-sets (definitions 'short-setf-with-fn)
                    `(,(xref 'short-setf-with-fn 'setf))))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp))
                               'failure))
    (check-ref-sets (definitions 'test-gf)
                    `(,(xref 'test-gf 'generic-function)
                      ,(xref 'test-gf '(method (number)))
                      ,(xref 'test-gf '(method ((eql 7))))
                      ,(xref 'test-gf '(method
                                        ((eql #.(find-package :cl))))))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :ccl :clisp
                                                      :cmucl))
                               'failure))
    (check-ref-sets (definitions '(setf setf-gf))
                    `(,(xref 'setf-gf 'setf-generic-function)
                      ,(xref 'setf-gf '(setf-method (string))))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :ccl :clisp
                                                      :cmucl :ecl))
                               'failure))
    (check-ref-sets (definitions 'setf-gf)
                    `(,(xref 'setf-gf 'generic-function)
                      ,(xref 'setf-gf '(method ()))
                      ,(xref 'setf-gf 'setf-generic-function)
                      ,(xref 'setf-gf '(setf-method (string))))))
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :clisp :cmucl :ecl))
                               'failure))
    (check-ref-sets (definitions 'my-comb)
                    `(,(xref 'my-comb 'method-combination))))
  ;; There _may_ be a GENERIC-FUNCTION and a SETF generic function too.
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (check-ref-sets (remove-if (lambda (dref)
                                 (or (typep dref 'generic-function-dref)
                                     (typep dref 'setf-function-dref)))
                               (definitions 'foo-a))
                    `(,(xref 'foo-a 'variable)
                      ,(xref 'foo-a '(accessor foo))))
    (check-ref-sets (remove 'generic-function (definitions 'foo-r)
                            :key #'dref-locative-type)
                    `(,(xref 'foo-r 'variable)
                      ,(xref 'foo-r '(reader foo))))
    (check-ref-sets (remove 'generic-function (definitions 'foo-w)
                            :key #'dref-locative-type)
                    `(,(xref 'foo-w 'variable)
                      ,(xref 'foo-w '(writer foo)))))
  ;; BAZ-AAA is not recognized as a structure accessor on most Lisps.
  ;; On CCL, (SETF BAZ-AAA) shows up as well. FIXME: Maybe that's how
  ;; it should be?
  (with-failure-expected ((and (alexandria:featurep '(:not (:or :sbcl)))
                               'failure))
    (check-ref-sets (definitions 'baz-aaa)
                    `(,(xref 'baz-aaa '(structure-accessor baz)))))
  (with-failure-expected ((alexandria:featurep '(:not :sbcl)))
    (check-ref-sets (definitions 'dynamic-extent)
                    `(,(xref 'dynamic-extent 'declaration))))
  (with-failure-expected ((alexandria:featurep :clisp))
    (check-ref-sets (definitions 'my-error)
                    `(,(xref 'my-error 'condition)
                      ,(xref 'my-error 'function))))
  (with-failure-expected ((alexandria:featurep '(:not :sbcl)))
    (check-ref-sets (definitions 'test-declaration)
                    `(,(xref 'test-declaration 'declaration))))
  (check-ref-sets (definitions 'xxx-rt)
                  `(,(xref 'xxx-rt 'readtable)))
  (check-ref-sets (definitions 'my-loc)
                  `(,(xref 'my-loc 'locative)))
  #+sbcl
  (check-ref-sets+ (definitions 'print)
                   `(,(xref 'print 'function)
                     ,(xref 'print '(unknown (:defoptimizer print
                                                 sb-c:derive-type)))
                     ,(xref 'print '(unknown (declaim print sb-c:defknown)))))
  ;; This is a primitive object, that (SWANK-BACKEND:FIND-DEFINITIONS
  ;; 'SB-C::CATCH-BLOCK) returns as a TYPE.
  #+sbcl
  (signals-not (locate-error)
    (definitions 'sb-c::catch-block))
  (with-test ("actualized")
    (with-failure-expected ((alexandria:featurep :clisp))
      (check-ref-sets (definitions 'foo :dtype 'type)
                      `(,(xref 'foo 'class)))))
  (with-test ("invalid dtype")
    (signals (error)
      (definitions nil :dtype '"x")))
  (is (endp (definitions 1)))
  (is (endp (definitions 1.3)))
  (is (endp (definitions '(x y)))))


(deftest test-dspec ()
  (check-dspec-roundtrip (dref '*some-var* 'variable))
  (check-dspec-roundtrip (dref 'bar 'constant))
  (check-dspec-roundtrip (dref 'bar 'macro))
  (check-dspec-roundtrip (dref 'block 'macro))
  (check-dspec-roundtrip (dref 'foo 'compiler-macro))
  (check-dspec-roundtrip (dref 'setf-fn 'setf-compiler-macro))
  (check-dspec-roundtrip (dref 'my-smac 'symbol-macro))
  (check-dspec-roundtrip (dref 'short-setf-with-fn 'setf))
  (check-dspec-roundtrip (dref 'setf-fn 'setf))
  (check-dspec-roundtrip (dref 'foo 'function))
  (check-dspec-roundtrip (dref 'test-gf 'generic-function))
  (with-failure-expected ((alexandria:featurep '(:or :clisp)))
    (check-dspec-roundtrip (dref 'setf-gf 'setf-generic-function)))
  (with-failure-expected ((alexandria:featurep '(:or :abcl :ccl :cmucl)))
    (check-dspec-roundtrip (dref 'setf-gf '(setf-method (string)))))
  (with-failure-expected ((alexandria:featurep '(:or :ecl)))
    (check-dspec-roundtrip (dref 'test-gf '(method ((eql 7)))))
    (check-dspec-roundtrip
     (dref 'test-gf '(method ((eql #.(find-package :cl)))))))
  (check-dspec-roundtrip (dref 'gf2 '(method :around (t))))
  (check-dspec-roundtrip (dref 'gf2 '(method :after (t))))
  (check-dspec-roundtrip (dref 'my-comb 'method-combination))
  (check-dspec-roundtrip (dref 'bar 'type))
  (check-dspec-roundtrip (dref 'foo 'class))
  (check-dspec-roundtrip (dref 'array 'class))
  (check-dspec-roundtrip (dref 'my-error 'condition))
  (check-dspec-roundtrip (dref  'dref 'package))
  (let ((dref (dref 'print '(unknown (:define-vop print print)) nil)))
    (when dref
      (check-dspec-roundtrip dref))))

(defun check-dspec-roundtrip (dref &optional (expected-result dref))
  (let* ((dspec (dref::definition-to-dspec dref))
         (swank-name (or (ignore-errors (dref::dref-function-name dref))
                         (dref-name dref)))
         (roundtripped (dref::dspec-to-definition dspec swank-name)))
    (when (is roundtripped
              :ctx ("DREF = ~S~%DPSEC = ~S" dref dspec))
      (is (xref= (capture roundtripped) (capture expected-result))
          :ctx ("DREF = ~S~%DPSEC = ~S" dref dspec)))))


(deftest test-arglist ()
  (test-macro-arg-names)
  (test-function-arg-names)
  (is (null (arglist (dref 'my-smac 'symbol-macro))))
  (test-arglist/macro)
  (test-arglist/compiler-macro)
  (test-arglist/setf)
  (test-arglist/function)
  (test-arglist/generic-function)
  (test-arglist/method)
  (test-arglist/type)
  (test-arglist/locative)
  (test-arglist/symbol-locative)
  (test-arglist/lambda))

(deftest test-macro-arg-names ()
  (is (equal '(x a b c)
             (dref::macro-arg-names '((&key (x y)) (a b) &key (c d))))))

(deftest test-function-arg-names ()
  (is (equal (dref::function-arg-names '(x &optional (o 1) &key (k 2 kp)))
             '(x o k kp)))
  (is (equal (dref::function-arg-names '(&key ((:xxx xxx))))
             '(xxx)))
  (is (equal (dref::function-arg-names '(&key ((:xxx xxx) nil xxxp)))
             '(xxx xxxp)))
  (is (equal (dref::function-arg-names '(&key ((:xxx xxx) nil xxxp)
                                         &allow-other-keys &aux (a 7)))
             '(xxx xxxp a))))

(deftest test-arglist/macro ()
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :allegro :clisp))
                               'failure))
    (is (or (equal (% (arglist (dref 'macro-with-fancy-args 'macro)))
                   '(x &optional (o 1) &key (k 2 kp)))
            (equal (arglist (dref 'macro-with-fancy-args 'macro))
                   '(x &optional (o 1) &key (k 2))))))
  #+sbcl
  (with-test ("special operator")
    (is (match-values (arglist (dref 'function 'macro))
          (equal * '(sb-c::thing))
          (eq * :macro)))))

(deftest test-arglist/compiler-macro ()
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :clisp :ecl))
                               'failure))
    (is (match-values (arglist (dref 'cmac 'compiler-macro))
          (equal * '(x &rest y))
          (eq * :macro)))))

(deftest test-arglist/setf ()
  (is (match-values (arglist (dref 'short-setf-with-undefined-fn 'setf))
        (:on-length-mismatch nil)
        (endp *)
        (null *)))
  (with-failure-expected (*failure-on-setf-arglist*)
    (is (match-values (arglist (dref 'short-setf-with-fn 'setf))
          (equal * '(x))
          (eq * :ordinary)))
    (is (match-values (arglist (dref 'short-setf-with-macro 'setf))
          (equal * '(x (&key y)))
          (eq * :macro))))
  (with-failure-expected (*failure-on-long-setf*)
    (signals-not (locate-error)
      (with-failure-expected (*failure-on-setf-arglist*)
        (is (match-values (arglist (dref 'long-setf 'setf))
              (equal * '(x))
              (eq * :ordinary)))))))

(deftest test-arglist/function ()
  (is (match-values (arglist (dref 'function-with-fancy-args 'function))
        (equal * '(x &optional (o 1) &key (k 2 kp)))
        (eq * :ordinary)))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp :ecl))
                               'failure))
    (is (match-values (arglist (dref 'traced-foo 'function))
          (equal * '(x))
          (eq * :ordinary))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (match-values (arglist (dref '(setf setf-fn) 'function))
          (equal * '(v))
          (eq * :ordinary)))))

(deftest test-arglist/generic-function ()
  (is (match-values (arglist (dref 'test-gf 'generic-function))
        (equal * '(x))
        (eq * :ordinary)))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp :ecl))
                               'failure))
    (is (match-values (arglist (dref 'traced-gf 'function))
          (equal * '(x))
          (eq * :ordinary))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (match-values (arglist (dref '(setf setf-gf) 'generic-function))
          (equal * '(v))
          (eq * :ordinary)))))

(deftest test-arglist/method ()
  (is (match-values (arglist (dref 'gf2 '(method :around (t))))
        (equal * '(x &key))
        (eq * :ordinary)))
  (is (match-values (arglist (dref 'gf2 '(method :after (t))))
        (equal * '(x &key y))
        (eq * :ordinary)))
  (is (match-values (arglist (dref 'gf2 '(method (number))))
        (equal * '(x &key ((:x y) t)))
        (eq * :ordinary)))
  (is (match-values (arglist (dref '(setf setf-gf) '(method (string))))
        (equal * '(v))
        (eq * :ordinary))))

(deftest test-arglist/type ()
  (with-failure-expected ((alexandria:featurep '(:or :abcl :allegro :clisp
                                                 :ccl :cmucl :ecl)))
    (is (match-values (arglist (dref 'bar 'type))
          (equal * '(x &rest r))
          (eq * :deftype))))
  (is (listp (arglist (dref 'debug0-non-constant-type 'type)))))

(deftest test-arglist/locative ()
  (is (match-values (arglist (dref 'loc-with-args 'locative))
        (equal * '((x y) &key z))
        (eq * :destructuring))))

(deftest test-arglist/symbol-locative ()
  (is (match-values (arglist (dref 'sloc1 'sloc))
        (equal * '(&key z))
        (eq * :macro))))

(deftest test-arglist/lambda ()
  (is (match-values (arglist (dref nil '(lambda :arglist ((x y) z)
                                         :arglist-type :macro)))
        (equal * '((x y) z))
        (eq * :macro))))


(deftest test-docstring ()
  (is (equal (docstring (xref 'foo-a 'variable))
             "FOO-A variable"))
  (is (equal (docstring (dref 'foo-a 'variable)) "FOO-A variable"))
  (is (equal (docstring (dref 'bar 'constant)) "BAR constant"))
  (is (equal (docstring (dref 'bar 'macro)) "BAR macro"))
  (signals-not (error)
    (docstring (dref 'function 'macro)))
  (is (equal (docstring (dref 'my-smac 'symbol-macro))
             "MY-SMAC symbol-macro"))
  (with-failure-expected ((and (alexandria:featurep
                                '(:or :abcl :allegro :ccl))
                               'failure))
    (is (equal (docstring (dref 'foo 'compiler-macro))
               "FOO compiler-macro")))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (equal (docstring (dref 'short-setf-with-fn 'setf))
               "SHORT-SETF-WITH-FN doc"))
    (is (equal (docstring (dref 'short-setf-with-undefined-fn 'setf))
               "SHORT-SETF-WITH-UNDEFINED-FN doc"))
    (is (equal (docstring (dref 'short-setf-with-macro 'setf))
               "SHORT-SETF-WITH-MACRO doc"))
    (is (equal (docstring (dref '(setf setf-fn) 'function))
               "SETF-FN setf")))
  (with-failure-expected ((and (alexandria:featurep '(:or :cmucl))
                               'failure))
    (is (equal (docstring (dref '(setf setf-gf) 'generic-function))
               "SETF-GF setf")))
  (is (equal (docstring (dref '(setf setf-gf) '(method (string))))
             "SETF-GF (setf-method (string))"))
  (is (equal (docstring (dref 'foo 'function)) "FOO function"))
  (with-failure-expected ((alexandria:featurep '(:or :abcl)))
    (is (equal (docstring (dref 'traced-foo 'function))
               "TRACED-FOO function")))
  (is (equal (docstring (dref 'test-gf 'generic-function))
             "TEST-GF generic-function"))
  (is (equal (docstring (dref 'traced-gf 'function))
             "TRACED-GF generic-function"))
  (is (equal (docstring (dref 'test-gf '(method (number))))
             "TEST-GF (method (number))"))
  (with-failure-expected ((alexandria:featurep '(:or :abcl :allegro)))
    (is (equal (docstring (dref 'my-comb 'method-combination))
               "MY-COMB method-combination")))
  (is (equal (docstring (dref 'foo-a '(accessor foo)))
             "FOO-A (accessor foo)"))
  (is (equal (docstring (dref 'foo-r '(reader foo)))
             "FOO-R (reader foo)"))
  (is (equal (docstring (dref 'foo-w '(writer foo)))
             "FOO-W (writer foo)"))
  (with-failure-expected ((and (alexandria:featurep '(:or :clisp :ecl))
                               'failure))
    (is (equal (docstring (dref 'baz-aaa '(structure-accessor baz)))
               "BAZ-AAA (structure-accessor baz)")))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (equal (docstring (dref 'bar 'type))
               "BAR type")))
  (is (equal (docstring (dref 'foo 'class))
             "FOO class"))
  (is (equal (docstring (dref 'my-error 'condition))
             "MY-ERROR condition"))
  (is (null (docstring (dref 'test-declaration 'declaration))))
  (is (null (docstring (dref 'dref 'asdf:system))))
  (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                               'failure))
    (is (equal (docstring (dref 'dref-test 'package))
               "Test package for DRef.")))
  (is (match-values (docstring (dref 'sloc 'locative))
        (equal * "SLOC locative")
        (eq * (find-package :dref-test))))
  (is (match-values (docstring (dref 'sloc1 'sloc))
        (equal * "SLOC1 sloc")
        (eq * (find-package :dref-test))))
  (is (match-values (docstring (dref 'var 'locative))
        (equal * "VAR locative")
        (eq * (find-package :dref-test))))
  (dolist (dref (definitions 'print :dtype 'unknown))
    (is (null (docstring dref))))
  (is (match-values (docstring (dref nil '(lambda :docstring "xxx"
                                           :docstring-package :dref)))
        (equal * "xxx")
        (eq * (find-package :dref)))))


;;;; TEST-SOURCE-LOCATION

(defparameter *source-location-test-cases*
  '(;; DREF::@VARIABLELIKE-LOCATIVES
    (foo-a variable (defvar foo-a))
    (foo-r variable (defvar foo-r))
    (foo-w variable (defvar foo-w))
    (bar constant (defconstant bar))
    ;; DREF::@MACROLIKE-LOCATIVES
    (bar macro (defmacro bar))
    (my-smac symbol-macro (define-symbol-macro my-smac))
    (foo compiler-macro (define-compiler-macro foo))
    (short-setf-with-fn setf (defsetf short-setf-with-fn) nil
     ;; No source location for DEFSETF on any implementation.
     t)
    ((setf setf-fn) function (defun (setf setf-fn)) nil
     #.(alexandria:featurep '(:or :allegro :cmucl)))
    ((setf setf-fn) compiler-macro
     (define-compiler-macro (setf setf-fn)) nil
     #.(alexandria:featurep '(:or :allegro :cmucl)))
    ((setf setf-gf) generic-function (defgeneric (setf setf-gf)) nil
     #.(alexandria:featurep '(:or :allegro :cmucl)))
    ((setf setf-gf) (method (string))
     (defmethod (setf setf-gf) ((v string))) nil
     #.(alexandria:featurep '(:or :allegro :cmucl)))
    ;; DREF::@FUNCTIONLIKE-LOCATIVES
    (foo function (defun foo))
    (|Foo| function (defun |Foo|))
    (traced-foo function (defun traced-foo))
    (test-gf generic-function (defgeneric test-gf))
    (test-gf (method (number)) (defmethod test-gf))
    (my-comb method-combination (define-method-combination my-comb))
    (foo-a (accessor foo) (defclass foo) (a :accessor foo-a))
    (foo-r (reader foo) (defclass foo) (r :reader foo-r))
    (foo-w (writer foo) (defclass foo) (w :writer foo-w))
    (baz structure (defstruct baz))
    (baz-aaa structure-accessor (defstruct baz) nil #+cmucl t)
    ;; DREF::@TYPELIKE-LOCATIVES
    (bar type (deftype bar))
    (foo type (defclass foo))
    (my-error type (define-condition my-error))
    (foo class (defclass foo))
    (test-declaration declaration (define-declaration test-declaration))
    ;; DREF::@CONDITION-SYSTEM-LOCATIVES
    (my-error condition (define-condition my-error))
    (some-restart restart (define-restart some-restart))
    ;; DREF::@PACKAGELIKE-LOCATIVES
    (mgl-pax asdf:system ())
    (mgl-pax package
     (eval-when (:compile-toplevel :load-toplevel :execute))
     (cl:defpackage))
    (xxx-rt readtable
     #-ecl "(named-readtables:defreadtable xxx-rt"
     #+ecl "

(unless (named-readtables:find-readtable 'xxx-rt)")
    ;; DREF-EXT::@DEFINING-LOCATIVE-TYPES
    (my-loc locative (define-locative-type my-loc))
    (object locative (define-locative-alias object class))))

(deftest test-source-location ()
  (signals-not (error)
    (is (null (source-location 777))))
  (signals-not (error)
    (let ((l (source-location 777 :error :error)))
      (is (and (listp l) (eq (first l) :error)))))
  (signals (error)
    (source-location 777 :error t))
  (test-make-source-location)
  (let ((*package* (find-package :dref-test)))
    (dolist (test-case *source-location-test-cases*)
      (apply #'check-source-location test-case)))
  (signals-not (error)
    (source-location (xref 'function 'locative)))
  (with-failure-expected ()
    (signals-not (error)
      (source-location (xref 'locative 'function)))))

(deftest test-make-source-location ()
  (let ((loc (make-source-location :file #P"xxx"
                                   :file-position 7
                                   :buffer "bbb"
                                   :snippet "(defun foo ())")))
    (is (equal (source-location-file loc) "xxx"))
    (is (eql (source-location-file-position loc) 7))
    (is (equal (source-location-buffer loc) "bbb"))
    (is (equal (source-location-buffer-position loc) 8))
    (is (equal (source-location-snippet loc) "(defun foo ())"))))

(defun working-locative-p (locative)
  (let ((type (locative-type locative)))
    (cond ((alexandria:featurep :abcl)
           nil)
          ((alexandria:featurep :clisp)
           nil)
          ((eq type 'symbol-macro)
           (alexandria:featurep '(:not :ccl)))
          ((eq type 'declaration)
           (alexandria:featurep :sbcl))
          ((eq type 'generic-function)
           ;; AllegroCL is off by one form.
           (alexandria:featurep '(:not :allegro)))
          ((eq type 'method-combination)
           (alexandria:featurep '(:not (:or :abcl :cmucl :ecl))))
          ((member type '(reader writer accessor))
           (alexandria:featurep '(:not (:or :abcl :cmucl :ecl))))
          ((eq type 'structure-accessor)
           (alexandria:featurep '(:not (:or :abcl :allegro :ecl))))
          ((eq type 'type)
           (alexandria:featurep '(:not :ecl)))
          ((eq type 'package)
           (alexandria:featurep '(:not (:or :abcl :allegro :clisp :cmucl
                                            :ecl))))
          (t
           t))))

(defun check-source-location (name locative prefix &optional alternative-prefix
                                                     failure-expected-p)
  (let* ((ref (xref name locative))
         (resolved (resolve ref nil)))
    ;; Test SOURCE-LOCATION with a REFERENCE and a resolved object if
    ;; there is one.
    (dolist (target (if resolved
                        (list ref resolved)
                        (list ref)))
      (with-test ((format nil "navigate to ~S" target))
        (with-failure-expected ((or (not (working-locative-p locative))
                                    failure-expected-p))
          (signals-not (error :msg (format nil "SOURCE-LOCATION ~S runs"
                                           target))
            (let ((location (source-location target)))
              (when (is (and (% location) (not (eq :error (first location))))
                        :msg `("Find source location for (~S ~S)."
                               ,name ,locative))
                (multiple-value-bind (file position)
                    (extract-source-location location)
                  (when (is file)
                    (let ((content (if (stringp prefix)
                                       (read-string-from-file-position
                                        file (or position 0)
                                        (max (length prefix)
                                             (length alternative-prefix)))
                                       (read-form-from-file-position
                                        file (or position 0)))))
                      (is (and (eq (not (listp prefix))
                                   (not (listp content)))
                               (or (alexandria:starts-with-subseq
                                    prefix content :test #'equal)
                                   (and alternative-prefix
                                        (alexandria:starts-with-subseq
                                         alternative-prefix content
                                         :test #'equal))))
                          :msg `("Find prefix ~S~@[ or ~S~] ~
                                    at source location~%~S~% ~
                                    for reference (~S ~S).~%~
                                    Form found was:~%~S."
                                 ,prefix ,alternative-prefix
                                 ,location ,name ,locative
                                 ,content)))))))))))))

(defun extract-source-location (location)
  (values (source-location-file location)
          (source-location-file-position location)))

(defun read-string-from-file-position (filename position n)
  (with-open-file (stream filename
                          :direction :input
                          :external-format dref::*utf-8-external-format*)
    (file-position stream position)
    (let ((string (make-string n)))
      (read-sequence string stream)
      string)))

(defun read-form-from-file-position (filename position)
  (with-open-file (stream filename
                          :direction :input
                          :external-format dref::*utf-8-external-format*)
    (file-position stream position)
    (read stream)))


(deftest test-hierarchy ()
  (is (equal (locative-type-direct-subs 'function)
             ;; DREF::@REVERSE-DEFINITION-ORDER
             '(structure-accessor setf-function generic-function))))


(deftest test-dtypes ()
  (test-widest-subtype-of-locative-type)
  (test-narrowest-supertype-of-locative-type)
  (test-dtypep)
  (test-cover-dtype)
  (test-inexact-dtype-cover-p))

(deftest test-widest-subtype-of-locative-type ()
  (is (eq (dref::widest-subtype-of-locative-type 'reader) nil))
  (is (eq (dref::widest-subtype-of-locative-type 'writer) nil))
  (is (eq (dref::widest-subtype-of-locative-type 'accessor) nil))
  (is (eq (dref::widest-subtype-of-locative-type 'method) 'method))
  (is (equal (dref::widest-subtype-of-locative-type 'type) 'class)))

(deftest test-narrowest-supertype-of-locative-type ()
  (is (eq (dref::narrowest-supertype-of-locative-type 'reader) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'writer) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'accessor) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'method) 'method))
  (is (eq (dref::narrowest-supertype-of-locative-type 'type) t)))


(deftest test-dtypep ()
  (test-dtypep/non-dref)
  (test-dtypep/locative-type)
  (test-dtypep/derived)
  (test-dtypep/with-locative-args)
  (test-dtypep/pseudo)
  (test-dtypep/member)
  (test-dtypep/satisfies))

(deftest test-dtypep/non-dref ()
  (signals (error)
    (dtypep 1 t))
  (signals (error)
    (dtypep (xref 'number 'class) 'top)))

(deftest test-dtypep/locative-type ()
  (is (not (dref::valid-type-specifier-p 'type)))
  (is (dtypep (dref 'xref 'class) 'type))
  (is (not (dtypep (dref 'print 'function) 'type))))

(deftest test-dtypep/derived ()
  (is (not (dtypep (locate (find-class 'xref)) '(and type condition))))
  (is (not (dtypep (dref 'xref 'class) '(and type condition))))
  (is (dtypep (dref 'foo-a '(accessor foo)) '(and reader writer)))
  (is (not (dtypep (dref 'foo-r '(reader foo)) '(and reader writer))))
  (is (not (dtypep (dref 'foo-w '(writer foo)) '(and reader writer))))
  (signals (error :pred "not a valid")
    (is (dtypep (dref 'foo-r '(reader foo)) '(or number reader))))
  (is (dtypep (locate #'print) '(not type)))
  (is (not (dtypep (locate (find-class 'xref)) '(not type))))
  (is (dtypep (dref 'bar 'type) '(and type (not class)))))

(deftest test-dtypep/with-locative-args ()
  (is (dtypep (dref 'test-gf '(method (number))) '(method (number))))
  (is (xref= (dref 'foo-r '(method (foo)))
             (xref 'foo-r '(reader foo))))
  (test-dtypep/with-locative-args/actualized))

(deftest test-dtypep/with-locative-args/actualized ()
  (is (dtypep (dref 'foo-r '(method (foo))) '(method (foo))))
  (is (dtypep (dref '(setf setf-fn) 'function) 'function))
  (is (dtypep (locate #'(setf setf-fn)) 'function))
  (is (dtypep (dref '(setf setf-gf) 'generic-function) 'generic-function))
  (is (dtypep (dref '(setf setf-gf) '(method (string)))
              '(method (string))))
  (is (dtypep (locate #'(setf setf-gf)) 'generic-function))
  (test-dtypep/accessor-writer-setf-name-change))

(deftest test-dtypep/accessor-writer-setf-name-change ()
  (is (dtypep (dref '(setf foo-a) '(method (t foo))) '(method (t foo)))))

(deftest test-dtypep/pseudo ()
  (is (not (dtypep (dref nil 'lambda) t)))
  (is (dtypep (dref nil 'lambda) 'top))
  (is (dtypep (dref nil 'lambda) 'pseudo)))

(deftest test-dtypep/member ()
  (is (not (dref::dtypep (dref 'number 'class) `(member ,(xref 't 'class)))))
  (is (dref::dtypep (dref 'number 'class) `(member ,(xref 'number 'class))))
  (is (dref::dtypep (dref 'number 'class) `(member ,(find-class 'number)))))

(deftest test-dtypep/satisfies ()
  (signals (error)
    (dref::dtypep #'print '(satisfies junk)))
  (signals (error)
    (dref::dtypep #'print '(satisfies)))
  (signals (error)
    (dref::dtypep #'print '(satisfies x y)))
  (signals (error)
    (dref::dtypep #'print '(satisfies "xv")))
  (signals (error)
    (dref::dtypep #'print '(satisfies oddp)))
  (is (not (dref::dtypep (locate #'print) '(satisfies locative-dref-p))))
  (is (dref::dtypep (dref 'class 'locative) '(satisfies locative-dref-p))))

(defun locative-dref-p (obj)
  (and (typep obj 'dref)
       (eq (dref-locative-type obj) 'locative)))


(deftest test-cover-dtype ()
  (test-cover-dtype/single)
  (test-cover-dtype/or)
  (test-cover-dtype/and)
  (test-cover-dtype/not)
  (test-cover-dtype/complex)
  (test-cover-dtype/compound)
  (test-cover-dtype/member)
  (test-cover-dtype/satisfies))

(defun set-equal-p (set1 set2)
  (and (endp (capture (set-difference set1 set2)))
       (endp (capture (set-difference set2 set1)))))

(deftest test-cover-dtype/single ()
  (with-test ("not negated")
    (is (eq (dref::cover-dtype/single nil nil) nil))
    (is (eq (dref::cover-dtype/single 'class nil) 'class))
    (is (eq (dref::cover-dtype/single 'type nil) 'type))
    (signals (error)
      (is (eq (dref::cover-dtype/single 'number nil) t))))
  (with-test ("negated")
    (is (eq (dref::cover-dtype/single nil t) nil))
    (is (eq (dref::cover-dtype/single 'class nil) 'class))
    (is (eq (dref::cover-dtype/single 'type nil) 'type))
    (signals (error)
      (is (eq (dref::cover-dtype/single 'number nil) nil)))))

(deftest test-cover-dtype/or ()
  (is (set-equal-p (dref::cover-dtype '(or)) '()))
  (is (set-equal-p (dref::cover-dtype '(or nil)) '()))
  (is (set-equal-p (dref::cover-dtype '(or pseudo)) (pseudo-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(or t)) (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(or top)) (locative-types)))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(or junk)))
  (is (set-equal-p (dref::cover-dtype '(or class))
                   '(class condition structure)))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(or number)))
  (is (set-equal-p (dref::cover-dtype '(or reader)) '(reader accessor)))
  (is (set-equal-p (dref::cover-dtype '(or reader writer))
                   '(reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(or reader (or writer)))
                   '(reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(or method))
                   '(method reader writer setf-method accessor)))
  (is (set-equal-p (dref::cover-dtype '(or method accessor))
                   '(method reader writer setf-method accessor))))

(deftest test-cover-dtype/and ()
  (is (set-equal-p (dref::cover-dtype '(and)) (locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and nil)) '()))
  (is (set-equal-p (dref::cover-dtype '(and pseudo)) (pseudo-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and t)) (lisp-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(and top)) (locative-types)))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(and junk)))
  (is (set-equal-p (dref::cover-dtype '(and class))
                   '(class condition structure)))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(and number)))
  (is (set-equal-p (dref::cover-dtype '(and reader)) '(reader accessor)))
  (is (set-equal-p (dref::cover-dtype '(and reader writer)) '(accessor)))
  (is (set-equal-p (dref::cover-dtype '(and reader (and writer))) '(accessor)))
  (is (set-equal-p (dref::cover-dtype '(and method))
                   '(method reader writer setf-method accessor)))
  (is (set-equal-p (dref::cover-dtype '(and method accessor)) '(accessor))))

(deftest test-cover-dtype/not ()
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(not)))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(not t nil)))
  (is (set-equal-p (dref::cover-dtype '(not nil)) (locative-types)))
  (is (set-equal-p (dref::cover-dtype '(not t)) (pseudo-locative-types)))
  (is (set-equal-p (dref::cover-dtype '(not class))
                   (set-difference (locative-types)
                                   (dref::locative-subtypes 'class))))
  (is (set-equal-p (dref::cover-dtype '(and t (not (method ()))))
                   (lisp-locative-types))))

(deftest test-cover-dtype/complex ()
  (is (set-equal-p (dref::cover-dtype '(and nil (or reader writer))) '()))
  (is (set-equal-p (dref::cover-dtype '(and t (or reader writer)))
                   '(reader writer accessor)))
  (is (set-equal-p (dref::cover-dtype '(and reader (or writer accessor)))
                   '(accessor)))
  (is (set-equal-p (dref::cover-dtype '(not (and class)))
                   (set-difference (locative-types)
                                   (dref::locative-subtypes 'class))))
  (is (set-equal-p (dref::cover-dtype '(not (or class)))
                   (set-difference (locative-types)
                                   (dref::locative-subtypes 'class)))))

(deftest test-cover-dtype/compound ()
  (is (set-equal-p (dref::cover-dtype '(method (number)))
                   '(method reader writer setf-method accessor))))

(deftest test-cover-dtype/member ()
  (is (set-equal-p (dref::cover-dtype '(member)) nil))
  (is (set-equal-p (dref::cover-dtype '(not (member))) (locative-types)))
  (is (set-equal-p (dref::cover-dtype `(member ,(xref 'number 'class)))
                   '(class condition structure)))
  (is (set-equal-p (dref::cover-dtype `(member ,(dref 'number 'class)))
                   '(class condition structure)))
  (is (set-equal-p (dref::cover-dtype `(member ,(find-class 'number)))
                   '(class condition structure)))
  (is (set-equal-p (dref::cover-dtype
                    `(member ,(dref 'test-gf '(method (number)))))
                   '(method reader writer setf-method accessor)))
  (is (set-equal-p (dref::cover-dtype
                    `(not (member ,(dref 'test-gf '(method (number))))))
                   (locative-types))))

(deftest test-cover-dtype/satisfies ()
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(satisfies)))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(satisfies "xy")))
  (signals (error :pred "Invalid DREF:DTYPE")
    (dref::cover-dtype '(satisfies f g)))
  (is (set-equal-p (dref::cover-dtype '(satisfies f)) (locative-types)))
  (is (set-equal-p (dref::cover-dtype '(not (satisfies f))) (locative-types))))


(deftest test-inexact-dtype-cover-p ()
  (is (not (dref::inexact-dtype-cover-p 'top)))
  (is (not (dref::inexact-dtype-cover-p t)))
  (is (not (dref::inexact-dtype-cover-p nil)))
  (is (not (dref::inexact-dtype-cover-p 'pseudo)))
  (is (not (dref::inexact-dtype-cover-p 'class)))
  (is (not (dref::inexact-dtype-cover-p '(or))))
  (is (not (dref::inexact-dtype-cover-p '(or class))))
  (is (not (dref::inexact-dtype-cover-p '(and))))
  (is (not (dref::inexact-dtype-cover-p '(and class))))
  (is (not (dref::inexact-dtype-cover-p '(not class))))
  (is (dref::inexact-dtype-cover-p '(method (number))))
  (is (dref::inexact-dtype-cover-p '(or (method (number)))))
  (is (dref::inexact-dtype-cover-p '(and (method (number)))))
  (is (dref::inexact-dtype-cover-p '(not (method (number)))))
  (is (dref::inexact-dtype-cover-p '(member)))
  (is (dref::inexact-dtype-cover-p '(satisfies foo))))


;;;; TEST-APROPOS

(defun mgl-pax::%test9jwern% ())
(defun %test9jwern% ())

(deftest test-apropos ()
  (with-failure-expected ((alexandria:featurep '(:or :abcl :clisp)))
    (with-test ("NAME is NIL")
      (check-ref-sets (dref-apropos nil :package :dref-test :external-only t)
                      `(,(xref 'test 'function)
                        ,(xref 'check-ref 'function)
                        ,(xref 'check-ref-sets 'function)
                        ,(xref 'check-source-location 'function)))
      (with-failure-expected ((alexandria:featurep '(:or :cmucl)))
        (signals-not (serious-condition)
          (is (null (find-if (lambda (dref)
                               (stringp (dref-name dref)))
                             (dref-apropos nil
                                           :package (find-package :dref))))))))
    (with-test ("NAME is a SYMBOL")
      (with-test ("PACKAGE is a symbol")
        (check-ref-sets (dref-apropos '%test9jwern% :package :mgl-pax)
                        `(,(xref 'mgl-pax::%test9jwern% 'function))))
      (with-test ("PACKAGE is a symbol matching a nickname")
        (check-ref-sets (dref-apropos '%test9jwern% :package :pax)
                        `(,(xref 'mgl-pax::%test9jwern% 'function))))
      (with-test ("NAME is a lower-case symbol")
        (check-ref-sets (dref-apropos '#:|%test9jwern%| :package :dref-test)
                        `(,(xref '%test9jwern% 'function)))))
    (with-test ("NAME is STRING")
      (with-test ("full match")
        (check-ref-sets (dref-apropos "test" :package :dref-test
                                             :external-only t)
                        `(,(xref 'dref-test:test 'function))))
      (with-test ("partial match")
        (check-ref-sets (dref-apropos "es" :package :dref-test
                                           :external-only t)
                        `(,(xref 'dref-test:test 'function))))
      (with-test ("case-sensitive")
        (with-test ("no match")
          (check-ref-sets (dref-apropos "es" :package :dref-test
                                             :external-only t
                                             :case-sensitive t)
                          ()))
        (with-test ("match")
          (check-ref-sets (dref-apropos "ES" :package :dref-test
                                             :external-only t
                                             :case-sensitive t)
                          `(,(xref 'dref-test:test 'function))))))
    (with-test ("PACKAGE is NIL")
      (check-ref-sets (dref-apropos '%test9jwern%)
                      `(,(xref 'dref-test::%test9jwern% 'function)
                        ,(xref 'mgl-pax::%test9jwern% 'function))))
    (with-test ("PACKAGE is STRING")
      (with-test ("full match")
        (check-ref-sets (dref-apropos '%test9jwern% :package "dref-test")
                        `(,(xref 'dref-test::%test9jwern% 'function))))
      (with-test ("partial match")
        (check-ref-sets (dref-apropos '%test9jwern% :package "dref")
                        `(,(xref 'dref-test::%test9jwern% 'function))))
      (with-test ("case-sensitive")
        (with-test ("no match")
          (check-ref-sets (dref-apropos '%test9jwern% :package "dref"
                                                      :case-sensitive t)
                          ()))
        (with-test ("match")
          (check-ref-sets (dref-apropos '%test9jwern% :package "DREF"
                                                      :case-sensitive t)
                          `(,(xref 'dref-test::%test9jwern%
                                   'function))))))
    (with-test ("PACKAGE is :ANY")
      (is (null (dref-apropos nil :package :any :dtype 'asdf:system)))
      (is (not (null (dref-apropos 'foo2 :package :any :dtype 'function)))))
    (with-test ("PACKAGE is :NONE")
      (check-ref-sets (dref-apropos "dref" :package :none)
                      `(,(xref (package-name :dref) 'package)
                        ,(xref (package-name :dref-ext) 'package)
                        ,(xref (package-name :dref-test) 'package)
                        ,(xref "dref" 'asdf:system)
                        ,(xref "dref/full" 'asdf:system)
                        ,(xref "dref-test" 'asdf:system)
                        ,(xref "dref-test/autoload" 'asdf:system)))))
  (with-test ("LOCATIVE-TYPES")
    (with-test ("only asdf systems")
      (is (= (length (dref-apropos nil :dtype 'asdf:system))
             (length (asdf:registered-systems)))))
    (with-test ("only packages")
      (is (= (length (dref-apropos nil :dtype 'package))
             (length (list-all-packages)))))
    ;; ABCL bundles an older named-readtables version, and somehow
    ;; named-readtables/doc and named-readtables/test can get loaded.
    (with-failure-expected ((alexandria:featurep :abcl))
      (with-test ("asdf systems and packages")
        (is (= (length (dref-apropos nil :dtype '(or asdf:system package)))
               (+ (length (asdf:registered-systems))
                  (length (list-all-packages)))))))
    #+sbcl
    (when (dref 'pax:clhs 'locative nil)
      (with-test ("PSEUDO")
        (is (plusp (length (% (dref-apropos 'print :dtype 'pseudo)))))))
    #+sbcl
    (with-test ("ALL")
      (is (= (+ (length (% (dref-apropos 'print :dtype t)))
                (length (% (dref-apropos 'print :dtype 'pseudo))))
             (length (% (dref-apropos 'print :dtype 'top)))))))
  (with-failure-expected ((alexandria:featurep :clisp))
    (with-test ("actualized")
      (check-ref-sets (dref-apropos 'foo :dtype 'type :package '#:dref-test)
                      `(,(xref 'foo 'class)))
      (check-ref-sets (dref-apropos 'foo :dtype '(type) :package '#:dref-test)
                      `(,(xref 'foo 'class)))
      (check-ref-sets (dref-apropos 'my-error :dtype 'type
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))
      (check-ref-sets (dref-apropos 'my-error :dtype '(type)
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))
      (check-ref-sets (dref-apropos 'my-error :dtype 'condition
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))
      (check-ref-sets (dref-apropos 'my-error :dtype '(condition)
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))
      (check-ref-sets (dref-apropos 'my-error :dtype 'class
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))
      (check-ref-sets (dref-apropos 'my-error :dtype '(class)
                                              :package '#:dref-test)
                      `(,(xref 'my-error 'condition)))))
  (with-test ("invalid dtype")
    (signals (error)
      (dref-apropos nil :dtype '"x"))
    (signals (error)
      (dref-apropos nil :package :none :dtype '"x")))
  (with-failure-expected ((alexandria:featurep '(:or :abcl :clisp)))
    (is (= (length (dref-apropos 'test-gf :package 'dref-test :dtype 'method))
           3))
    (check-ref-sets (dref-apropos 'test-gf :package 'dref-test
                                           :dtype '(method (number)))
                    `(,(xref 'test-gf '(method (number))))))
  (with-test ("setf name")
    (with-failure-expected ((and (alexandria:featurep '(:or :abcl))
                                 'failure))
      (check-ref-sets (dref-apropos 'setf-fn :package 'dref-test)
                      (list (xref 'setf-fn 'setf-function)
                            (xref 'setf-fn 'setf-compiler-macro))))
    (with-failure-expected ((and (alexandria:featurep '(:or :abcl :clisp))
                                 'failure))
      (check-ref-sets (dref-apropos "setf-fn" :package 'dref-test)
                      (list (xref 'setf-fn 'setf-function)
                            (xref 'setf-fn 'setf-compiler-macro))))))


(deftest test-all ()
  (let ((dref::*check-locate* t))
    (test-util)
    (test-locate)
    (test-definitions)
    (test-dspec)
    (test-arglist)
    (test-docstring)
    (test-source-location)
    (test-hierarchy)
    (test-dtypes)
    (test-apropos)))

(defun test (&key (debug nil) (print 'unexpected) (describe *describe*))
  ;; Bind *PACKAGE* so that names of tests printed have package names,
  ;; and M-. works on them in Slime.
  (handler-bind ((warning (lambda (c)
                            (when (expected-style-warning-p c)
                              (muffle-warning)))))
    (with-compilation-unit (:override t)
      (let ((*package* (find-package :common-lisp))
            (*print-duration* nil)
            (*print-compactly* t)
            (*defer-describe* t))
        (warn-on-tests-not-run ((find-package :dref-test))
          (print (try 'test-all :debug debug :print print
                                :describe describe)))))))

(defun expected-style-warning-p (c)
  (search "junk" (princ-to-string c) :test #'equalp))

#+nil
(test)

#+nil
(test-all)
